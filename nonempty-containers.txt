-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-empty variants of containers data types, with full API
--   
--   Efficient and optimized non-empty versions of types from
--   <i>containers</i>. Inspired by <i>non-empty-containers</i> library,
--   except attempting a more faithful port (with under-the-hood
--   optimizations) of the full <i>containers</i> API.
@package nonempty-containers
@version 0.1.0.0


-- | Unsafe internal-use functions used in the implementation of
--   <a>Data.IntSet.NonEmpty</a>. These functions can potentially be used
--   to break the abstraction of <a>NEIntSet</a> and produce unsound sets,
--   so be wary!
module Data.IntSet.NonEmpty.Internal

-- | A non-empty set of values <tt>a</tt>. At least one value exists in an
--   <tt><a>NEIntSet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEIntSet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NEIntSet</a> provide an assurance
--   that the result has at least one item.
--   
--   <a>Data.IntSet.NonEmpty</a> re-exports the API of <a>Data.IntSet</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NEIntSet</a>, but functions
--   that might potentially return an empty map (like <a>delete</a>) return
--   a <a>IntSet</a> instead.
--   
--   You can directly construct an <a>NEIntSet</a> with the API from
--   <a>Data.IntSet.NonEmpty</a>; it's more or less the same as
--   constructing a normal <a>IntSet</a>, except you don't have access to
--   <a>empty</a>. There are also a few ways to construct an
--   <a>NEIntSet</a> from a <a>IntSet</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyIntSet</a> smart constructor will convert a
--   <tt><a>IntSet</a> a</tt> into a <tt><a>Maybe</a> (<a>NEIntSet</a>
--   a)</tt>, returning <a>Nothing</a> if the original <a>IntSet</a> was
--   empty.</li>
--   <li>You can use the <a>insertIntSet</a> family of functions to insert
--   a value into a <a>IntSet</a> to create a guarunteed
--   <a>NEIntSet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>IntSet</a> to reveal it as either containing a
--   <a>NEIntSet</a> or an empty map.</li>
--   <li><a>withNEIntSet</a> offers a continuation-based interface for
--   deconstructing a <a>IntSet</a> and treating it as if it were an
--   <a>NEIntSet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEIntSet</a> into a <a>IntSet</a> with
--   <a>toIntSet</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEIntSet
NEIntSet :: !Key -> !IntSet -> NEIntSet

-- | invariant: must be smaller than smallest value in set
[neisV0] :: NEIntSet -> !Key
[neisIntSet] :: NEIntSet -> !IntSet
type Key = Int

-- | <i>O(log n)</i>. Smart constructor for an <a>NEIntSet</a> from a
--   <a>IntSet</a>. Returns <a>Nothing</a> if the <a>IntSet</a> was
--   originally actually empty, and <tt><a>Just</a> n</tt> with an
--   <a>NEIntSet</a>, if the <a>IntSet</a> was not empty.
--   
--   <a>nonEmptyIntSet</a> and <tt><a>maybe</a> <a>empty</a>
--   <a>toIntSet</a></tt> form an isomorphism: they are perfect
--   structure-preserving inverses of eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>IntSet</a> being an <a>NEIntSet</a>.
--   
--   <pre>
--   nonEmptyIntSet (Data.IntSet.fromList [3,5]) == fromList 3:|[5]
--   </pre>
nonEmptyIntSet :: IntSet -> Maybe NEIntSet

-- | <i>O(log n)</i>. Convert a non-empty set back into a normal
--   possibly-empty map, for usage with functions that expect
--   <a>IntSet</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the set in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyIntSet</a> and <tt><a>maybe</a> <a>empty</a>
--   <a>toIntSet</a></tt> form an isomorphism: they are perfect
--   structure-preserving inverses of eachother.
--   
--   <pre>
--   toIntSet (fromList ((3,"a") :| [(5,"b")])) == Data.IntSet.fromList [(3,"a"), (5,"b")]
--   </pre>
toIntSet :: NEIntSet -> IntSet

-- | <i>O(1)</i>. Create a singleton set.
singleton :: Key -> NEIntSet

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: NonEmpty Key -> NEIntSet

-- | <i>O(n)</i>. Convert the set to a non-empty list of elements.
toList :: NEIntSet -> NonEmpty Key

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The union of two sets, preferring
--   the first set when equal elements are encountered.
union :: NEIntSet -> NEIntSet -> NEIntSet

-- | The union of a non-empty list of sets
unions :: Foldable1 f => f NEIntSet -> NEIntSet

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: NEIntSet -> Bool

-- | <i>O(log n)</i>. Insert new value into a set where values are
--   <i>strictly greater than</i> the new values That is, the new value
--   must be <i>strictly less than</i> all values present in the
--   <a>IntSet</a>. /The precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.IntSet.insert</tt>, it
--   saves a constant factor for value comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the value type.
insertMinIntSet :: Key -> IntSet -> IntSet

-- | <i>O(log n)</i>. Insert new value into a set where values are
--   /strictly less than<i> the new value. That is, the new value must be
--   </i>strictly greater than<i> all values present in the <a>IntSet</a>.
--   </i>The precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.IntSet.insert</tt>, it
--   saves a constant factor for value comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the value type.
insertMaxIntSet :: Key -> IntSet -> IntSet
instance GHC.Classes.Eq Data.IntSet.NonEmpty.Internal.NEIntSet
instance GHC.Classes.Ord Data.IntSet.NonEmpty.Internal.NEIntSet
instance GHC.Show.Show Data.IntSet.NonEmpty.Internal.NEIntSet
instance GHC.Read.Read Data.IntSet.NonEmpty.Internal.NEIntSet
instance Control.DeepSeq.NFData Data.IntSet.NonEmpty.Internal.NEIntSet
instance Data.Data.Data Data.IntSet.NonEmpty.Internal.NEIntSet
instance GHC.Base.Semigroup Data.IntSet.NonEmpty.Internal.NEIntSet

module Data.IntSet.NonEmpty

-- | A non-empty set of values <tt>a</tt>. At least one value exists in an
--   <tt><a>NEIntSet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEIntSet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NEIntSet</a> provide an assurance
--   that the result has at least one item.
--   
--   <a>Data.IntSet.NonEmpty</a> re-exports the API of <a>Data.IntSet</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NEIntSet</a>, but functions
--   that might potentially return an empty map (like <a>delete</a>) return
--   a <a>IntSet</a> instead.
--   
--   You can directly construct an <a>NEIntSet</a> with the API from
--   <a>Data.IntSet.NonEmpty</a>; it's more or less the same as
--   constructing a normal <a>IntSet</a>, except you don't have access to
--   <a>empty</a>. There are also a few ways to construct an
--   <a>NEIntSet</a> from a <a>IntSet</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyIntSet</a> smart constructor will convert a
--   <tt><a>IntSet</a> a</tt> into a <tt><a>Maybe</a> (<a>NEIntSet</a>
--   a)</tt>, returning <a>Nothing</a> if the original <a>IntSet</a> was
--   empty.</li>
--   <li>You can use the <a>insertIntSet</a> family of functions to insert
--   a value into a <a>IntSet</a> to create a guarunteed
--   <a>NEIntSet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>IntSet</a> to reveal it as either containing a
--   <a>NEIntSet</a> or an empty map.</li>
--   <li><a>withNEIntSet</a> offers a continuation-based interface for
--   deconstructing a <a>IntSet</a> and treating it as if it were an
--   <a>NEIntSet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEIntSet</a> into a <a>IntSet</a> with
--   <a>toIntSet</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEIntSet
type Key = Int

-- | <i>O(1)</i> match, <i>O(log n)</i> usage of contents. The
--   <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow you to treat a
--   <a>IntSet</a> as if it were either a <tt><a>IsNonEmpty</a> n</tt>
--   (where <tt>n</tt> is a <a>NEIntSet</a>) or an <a>IsEmpty</a>.
--   
--   For example, you can pattern match on a <a>IntSet</a>:
--   
--   <pre>
--   myFunc :: <a>IntSet</a> X -&gt; Y
--   myFunc (<a>IsNonEmpty</a> n) =  -- here, the user provided a non-empty set, and <tt>n</tt> is the <a>NEIntSet</a>
--   myFunc <a>IsEmpty</a>        =  -- here, the user provided an empty set
--   </pre>
--   
--   Matching on <tt><a>IsNonEmpty</a> n</tt> means that the original
--   <a>IntSet</a> was <i>not</i> empty, and you have a verified-non-empty
--   <a>NEIntSet</a> <tt>n</tt> to use.
--   
--   Note that patching on this pattern is <i>O(1)</i>. However, using the
--   contents requires a <i>O(log n)</i> cost that is deferred until after
--   the pattern is matched on (and is not incurred at all if the contents
--   are never used).
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsNonEmpty</a> to
--   convert a <a>NEIntSet</a> back into a <a>IntSet</a>, obscuring its
--   non-emptiness (see <a>toIntSet</a>).
pattern IsNonEmpty :: NEIntSet -> IntSet

-- | <i>O(1)</i>. The <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow
--   you to treat a <a>IntSet</a> as if it were either a
--   <tt><a>IsNonEmpty</a> n</tt> (where <tt>n</tt> is a <a>NEIntSet</a>)
--   or an <a>IsEmpty</a>.
--   
--   Matching on <a>IsEmpty</a> means that the original <a>IntSet</a> was
--   empty.
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsEmpty</a> as an
--   expression, and it will be interpreted as <a>empty</a>.
--   
--   See <a>IsNonEmpty</a> for more information.
pattern IsEmpty :: IntSet

-- | <i>O(log n)</i>. Smart constructor for an <a>NEIntSet</a> from a
--   <a>IntSet</a>. Returns <a>Nothing</a> if the <a>IntSet</a> was
--   originally actually empty, and <tt><a>Just</a> n</tt> with an
--   <a>NEIntSet</a>, if the <a>IntSet</a> was not empty.
--   
--   <a>nonEmptyIntSet</a> and <tt><a>maybe</a> <a>empty</a>
--   <a>toIntSet</a></tt> form an isomorphism: they are perfect
--   structure-preserving inverses of eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>IntSet</a> being an <a>NEIntSet</a>.
--   
--   <pre>
--   nonEmptyIntSet (Data.IntSet.fromList [3,5]) == fromList 3:|[5]
--   </pre>
nonEmptyIntSet :: IntSet -> Maybe NEIntSet

-- | <i>O(log n)</i>. Convert a non-empty set back into a normal
--   possibly-empty map, for usage with functions that expect
--   <a>IntSet</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the set in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyIntSet</a> and <tt><a>maybe</a> <a>empty</a>
--   <a>toIntSet</a></tt> form an isomorphism: they are perfect
--   structure-preserving inverses of eachother.
--   
--   <pre>
--   toIntSet (fromList ((3,"a") :| [(5,"b")])) == Data.IntSet.fromList [(3,"a"), (5,"b")]
--   </pre>
toIntSet :: NEIntSet -> IntSet

-- | <i>O(log n)</i>. A general continuation-based way to consume a
--   <a>IntSet</a> as if it were an <a>NEIntSet</a>.
--   <tt><a>withNEIntSet</a> def f</tt> will take a <a>IntSet</a>. If set
--   is empty, it will evaluate to <tt>def</tt>. Otherwise, a non-empty set
--   <a>NEIntSet</a> will be fed to the function <tt>f</tt> instead.
--   
--   <pre>
--   <a>nonEmptyIntSet</a> == <a>withNEIntSet</a> <a>Nothing</a> <a>Just</a>
--   </pre>
withNEIntSet :: r -> (NEIntSet -> r) -> IntSet -> r

-- | <i>O(log n)</i>. Convert a <a>IntSet</a> into an <a>NEIntSet</a> by
--   adding a value. Because of this, we know that the set must have at
--   least one element, and so therefore cannot be empty.
--   
--   See <a>insertIntSetMin</a> for a version that is constant-time if the
--   new value is <i>strictly smaller than</i> all values in the original
--   set
--   
--   <pre>
--   insertIntSet 4 (Data.IntSet.fromList [5, 3]) == fromList (3 :| [4, 5])
--   insertIntSet 4 Data.IntSet.empty == singleton 4 "c"
--   </pre>
insertIntSet :: Key -> IntSet -> NEIntSet

-- | <i>O(1)</i> Convert a <a>IntSet</a> into an <a>NEIntSet</a> by adding
--   a value where the value is <i>strictly less than</i> all values in the
--   input set The values in the original map must all be <i>strictly
--   greater than</i> the new value. <i>The precondition is not
--   checked.</i>
--   
--   <pre>
--   insertIntSetMin 2 (Data.IntSet.fromList [5, 3]) == fromList (2 :| [3, 5])
--   valid (insertIntSetMin 2 (Data.IntSet.fromList [5, 3])) == True
--   valid (insertIntSetMin 7 (Data.IntSet.fromList [5, 3])) == False
--   valid (insertIntSetMin 3 (Data.IntSet.fromList [5, 3])) == False
--   </pre>
insertIntSetMin :: Key -> IntSet -> NEIntSet

-- | <i>O(1)</i> Convert a <a>IntSet</a> into an <a>NEIntSet</a> by adding
--   a value where the value is <i>strictly less than</i> all values in the
--   input set The values in the original map must all be <i>strictly
--   greater than</i> the new value. <i>The precondition is not
--   checked.</i>
--   
--   While this has the same asymptotics as <a>insertIntSet</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
--   
--   <pre>
--   insertIntSetMin 7 (Data.IntSet.fromList [5, 3]) == fromList (3 :| [5, 7])
--   valid (insertIntSetMin 7 (Data.IntSet.fromList [5, 3])) == True
--   valid (insertIntSetMin 2 (Data.IntSet.fromList [5, 3])) == False
--   valid (insertIntSetMin 5 (Data.IntSet.fromList [5, 3])) == False
--   </pre>
insertIntSetMax :: Key -> IntSet -> NEIntSet

-- | <i>O(log n)</i>. Unsafe version of <a>nonEmptyIntSet</a>. Coerces a
--   <a>IntSet</a> into an <a>NEIntSet</a>, but is undefined (throws a
--   runtime exception when evaluation is attempted) for an empty
--   <a>IntSet</a>.
unsafeFromIntSet :: IntSet -> NEIntSet

-- | <i>O(1)</i>. Create a singleton set.
singleton :: Key -> NEIntSet

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: NonEmpty Key -> NEIntSet

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. /The
--   precondition (input list is ascending) is not checked./
fromAscList :: NonEmpty Key -> NEIntSet

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: NonEmpty Key -> NEIntSet

-- | <i>O(log n)</i>. Insert an element in a set. If the set already
--   contains an element equal to the given value, it is replaced with the
--   new value.
insert :: Key -> NEIntSet -> NEIntSet

-- | <i>O(log n)</i>. Delete an element from a set.
delete :: Key -> NEIntSet -> IntSet

-- | <i>O(log n)</i>. Is the element in the set?
member :: Key -> NEIntSet -> Bool

-- | <i>O(log n)</i>. Is the element not in the set?
notMember :: Key -> NEIntSet -> Bool

-- | <i>O(log n)</i>. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList (3 :| [5])) == Nothing
--   lookupLT 5 (fromList (3 :| [5])) == Just 3
--   </pre>
lookupLT :: Key -> NEIntSet -> Maybe Key

-- | <i>O(log n)</i>. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupLT 4 (fromList (3 :| [5])) == Just 5
--   lookupLT 5 (fromList (3 :| [5])) == Nothing
--   </pre>
lookupGT :: Key -> NEIntSet -> Maybe Key

-- | <i>O(log n)</i>. Find largest element smaller or equal to the given
--   one.
--   
--   <pre>
--   lookupLT 2 (fromList (3 :| [5])) == Nothing
--   lookupLT 4 (fromList (3 :| [5])) == Just 3
--   lookupLT 5 (fromList (3 :| [5])) == Just 5
--   </pre>
lookupLE :: Key -> NEIntSet -> Maybe Key

-- | <i>O(log n)</i>. Find smallest element greater or equal to the given
--   one.
--   
--   <pre>
--   lookupLT 3 (fromList (3 :| [5])) == Just 3
--   lookupLT 4 (fromList (3 :| [5])) == Just 5
--   lookupLT 6 (fromList (3 :| [5])) == Nothing
--   </pre>
lookupGE :: Key -> NEIntSet -> Maybe Key

-- | <i>O(1)</i>. The number of elements in the set. Guaranteed to be
--   greater than zero.
size :: NEIntSet -> Int

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: NEIntSet -> NEIntSet -> Bool

-- | <i>O(n+m)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: NEIntSet -> NEIntSet -> Bool

-- | <i>O(n+m)</i>. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList (2:|[4,6]))   (fromList (1:|[3]))     == True
--   disjoint (fromList (2:|[4,6,8])) (fromList (2:|[3,5,7])) == False
--   disjoint (fromList (1:|[2]))     (fromList (1:|[2,3,4])) == False
--   </pre>
disjoint :: NEIntSet -> NEIntSet -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The union of two sets, preferring
--   the first set when equal elements are encountered.
union :: NEIntSet -> NEIntSet -> NEIntSet

-- | The union of a non-empty list of sets
unions :: Foldable1 f => f NEIntSet -> NEIntSet

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Difference of two sets.
--   
--   Returns a potentially empty set (<a>IntSet</a>) because the first set
--   might be a subset of the second set, and therefore have all of its
--   elements removed.
difference :: NEIntSet -> NEIntSet -> IntSet

-- | Same as <a>difference</a>.
(\\) :: NEIntSet -> NEIntSet -> IntSet

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The intersection of two sets.
--   
--   Returns a potentially empty set (<a>IntSet</a>), because the two sets
--   might have an empty intersection.
--   
--   Elements of the result come from the first set, so for example
--   
--   <pre>
--   import qualified Data.IntSet.NonEmpty as NES
--   data AB = A | B deriving Show
--   instance Ord AB where compare _ _ = EQ
--   instance Eq AB where _ == _ = True
--   main = print (NES.singleton A `NES.intersection` NES.singleton B,
--                 NES.singleton B `NES.intersection` NES.singleton A)
--   </pre>
--   
--   prints <tt>(fromList (A:|[]),fromList (B:|[]))</tt>.
intersection :: NEIntSet -> NEIntSet -> IntSet

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
--   
--   Returns a potentially empty set (<a>IntSet</a>) because the predicate
--   might filter out all items in the original non-empty set.
filter :: (Key -> Bool) -> NEIntSet -> IntSet

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two non-empty sets:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; 3) (fromList (5 :| [3])) == These (singleton 5) (singleton 3)
--   partition (&lt; 7) (fromList (5 :| [3])) == This  (fromList (3 :| [5]))
--   partition (&gt; 7) (fromList (5 :| [3])) == That  (fromList (3 :| [5]))
--   </pre>
partition :: (Key -> Bool) -> NEIntSet -> These NEIntSet NEIntSet

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> x set</tt>) is
--   potentially a <a>These</a> containing up to two <a>NEIntSet</a>s based
--   on splitting the set into sets containing items before and after the
--   value <tt>x</tt>. It will never return a set that contains <tt>x</tt>
--   itself.
--   
--   <ul>
--   <li><a>Nothing</a> means that <tt>x</tt> was the only value in the the
--   original set, and so there are no items before or after it.</li>
--   <li><tt><a>Just</a> (<a>This</a> n1)</tt> means <tt>x</tt> was larger
--   than or equal to all items in the set, and <tt>n1</tt> is the entire
--   original set (minus <tt>x</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>That</a> n2)</tt> means <tt>x</tt> was smaller
--   than or equal to all items in the set, and <tt>n2</tt> is the entire
--   original set (minus <tt>x</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>These</a> n1 n2)</tt> gives <tt>n1</tt> (the
--   set of all values from the original set less than <tt>x</tt>) and
--   <tt>n2</tt> (the set of all values from the original set greater than
--   <tt>x</tt>).</li>
--   </ul>
--   
--   <pre>
--   split 2 (fromList (5 :| [3])) == Just (That  (fromList (3 :| [5]))      )
--   split 3 (fromList (5 :| [3])) == Just (That  (singleton 5)              )
--   split 4 (fromList (5 :| [3])) == Just (These (singleton 3) (singleton 5))
--   split 5 (fromList (5 :| [3])) == Just (This  (singleton 3)              )
--   split 6 (fromList (5 :| [3])) == Just (This  (fromList (3 :| [5]))      )
--   split 5 (singleton 5)         == Nothing
--   </pre>
split :: Key -> NEIntSet -> Maybe (These NEIntSet NEIntSet)

-- | <i>O(log n)</i>. The expression (<tt><tt>splitLookup</tt> x set</tt>)
--   splits a set just like <a>split</a> but also returns <tt><a>member</a>
--   x set</tt> (whether or not <tt>x</tt> was in <tt>set</tt>)
--   
--   <pre>
--   splitMember 2 (fromList (5 :| [3])) == (False, Just (That  (fromList (3 :| [5)]))))
--   splitMember 3 (fromList (5 :| [3])) == (True , Just (That  (singleton 5)))
--   splitMember 4 (fromList (5 :| [3])) == (False, Just (These (singleton 3) (singleton 5)))
--   splitMember 5 (fromList (5 :| [3])) == (True , Just (This  (singleton 3))
--   splitMember 6 (fromList (5 :| [3])) == (False, Just (This  (fromList (3 :| [5])))
--   splitMember 5 (singleton 5)         == (True , Nothing)
--   </pre>
splitMember :: Key -> NEIntSet -> (Bool, Maybe (These NEIntSet NEIntSet))

-- | <i>O(1)</i>. Decompose a set into pieces based on the structure of the
--   underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first subset less than all elements in the second, and so on).
--   
--   Note that the current implementation does not return more than four
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: NEIntSet -> NonEmpty NEIntSet

-- | <i>O(n*log n)</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Key -> Key) -> NEIntSet -> NEIntSet

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elemsList set = foldr (:) [] set
--   </pre>
foldr :: (Key -> b -> b) -> b -> NEIntSet -> b

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   descElemsList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> Key -> a) -> a -> NEIntSet -> a

-- | <i>O(n)</i>. A version of <a>foldr</a> that uses the value at the
--   maximal value in the set as the starting value.
--   
--   Note that, unlike <a>foldr1</a> for <a>IntSet</a>, this function is
--   total if the input function is total.
foldr1 :: (Key -> Key -> Key) -> NEIntSet -> Key

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal value in the set as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>IntSet</a>, this function is
--   total if the input function is total.
foldl1 :: (Key -> Key -> Key) -> NEIntSet -> Key

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (Key -> b -> b) -> b -> NEIntSet -> b

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> Key -> a) -> a -> NEIntSet -> a

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (Key -> Key -> Key) -> NEIntSet -> Key

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (Key -> Key -> Key) -> NEIntSet -> Key

-- | <i>O(1)</i>. The minimal element of a set. Note that this is total,
--   making <a>lookupMin</a> obsolete. It is constant-time, so has better
--   asymptotics than <tt>Data.IntSet.lookupMin</tt> and
--   <tt>Data.Map.findMin</tt> as well.
--   
--   <pre>
--   findMin (fromList (5 :| [3])) == 3
--   </pre>
findMin :: NEIntSet -> Key

-- | <i>O(log n)</i>. The maximal key of a set Note that this is total,
--   making <a>lookupMin</a> obsolete.
--   
--   <pre>
--   findMax (fromList (5 :| [3])) == 5
--   </pre>
findMax :: NEIntSet -> Key

-- | <i>O(1)</i>. Delete the minimal element. Returns a potentially empty
--   set (<a>IntSet</a>), because we might delete the final item in a
--   singleton set. It is constant-time, so has better asymptotics than
--   <tt>Data.IntSet.deleteMin</tt>.
--   
--   <pre>
--   deleteMin (fromList (5 :| [3, 7])) == Data.IntSet.fromList [5, 7]
--   deleteMin (singleton 5) == Data.IntSet.empty
--   </pre>
deleteMin :: NEIntSet -> IntSet

-- | <i>O(log n)</i>. Delete the maximal element. Returns a potentially
--   empty set (<a>IntSet</a>), because we might delete the final item in a
--   singleton set.
--   
--   <pre>
--   deleteMax (fromList (5 :| [3, 7])) == Data.IntSet.fromList [3, 5]
--   deleteMax (singleton 5) == Data.IntSet.empty
--   </pre>
deleteMax :: NEIntSet -> IntSet

-- | <i>O(1)</i>. Delete and find the minimal element. It is constant-time,
--   so has better asymptotics that <tt>Data.IntSet.minView</tt> for
--   <a>IntSet</a>.
--   
--   Note that unlike <tt>Data.IntSet.deleteFindMin</tt> for <a>IntSet</a>,
--   this cannot ever fail, and so is a total function. However, the result
--   <a>IntSet</a> is potentially empty, since the original set might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMin (fromList (5 :| [3, 10])) == (3, Data.IntSet.fromList [5, 10])
--   </pre>
deleteFindMin :: NEIntSet -> (Key, IntSet)

-- | <i>O(log n)</i>. Delete and find the minimal element.
--   
--   Note that unlike <tt>Data.IntSet.deleteFindMax</tt> for <a>IntSet</a>,
--   this cannot ever fail, and so is a total function. However, the result
--   <a>IntSet</a> is potentially empty, since the original set might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMax (fromList (5 :| [3, 10])) == (10, Data.IntSet.fromList [3, 5])
--   </pre>
deleteFindMax :: NEIntSet -> (Key, IntSet)

-- | <i>O(n)</i>. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order.
elems :: NEIntSet -> NonEmpty Key

-- | <i>O(n)</i>. Convert the set to a non-empty list of elements.
toList :: NEIntSet -> NonEmpty Key

-- | <i>O(n)</i>. Convert the set to an ascending non-empty list of
--   elements.
toAscList :: NEIntSet -> NonEmpty Key

-- | <i>O(n)</i>. Convert the set to a descending non-empty list of
--   elements.
toDescList :: NEIntSet -> NonEmpty Key

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: NEIntSet -> Bool


-- | Unsafe internal-use functions used in the implementation of
--   <a>Data.Map.NonEmpty</a>. These functions can potentially be used to
--   break the abstraction of <a>NEMap</a> and produce unsound sets, so be
--   wary!
module Data.Map.NonEmpty.Internal

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNEMap</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a <a>Map</a> with <a>toMap</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NEMap k a
NEMap :: !k -> a -> !Map k a -> NEMap k a

-- | invariant: must be smaller than smallest key in map
[nemK0] :: NEMap k a -> !k
[nemV0] :: NEMap k a -> a
[nemMap] :: NEMap k a -> !Map k a

-- | <i>O(1)</i>. A map with a single element.
--   
--   <pre>
--   singleton 1 'a'        == fromList ((1, 'a') :| [])
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: k -> a -> NEMap k a

-- | <i>O(log n)</i>. Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Map</a> being an <a>NEMap</a>.
--   
--   <pre>
--   nonEmptyMap (Data.Map.fromList [(3,"a"), (5,"b")]) == fromList ((3,"a") :| [(5,"b")])
--   </pre>
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <a>fromAscList</a>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
--   
--   <pre>
--   fromList ((5,"a") :| [(3,"b"), (5, "c")]) == fromList ((5,"c") :| [(3,"b")])
--   fromList ((5,"c") :| [(3,"b"), (5, "a")]) == fromList ((5,"a") :| [(3,"b")])
--   </pre>
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
--   
--   <pre>
--   toList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "bx") :| [(5, "ax")])
--   </pre>
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   See <a>insertMapWith</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "xxxa")])
--   insertWith (++) 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "a"), (7, "C")])
--   </pre>
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a non-empty list of maps.
--   
--   <pre>
--   unions (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions (fromList ((5, "A3") :| [(3, "B3")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "a") :| [(3, "b")])])
--       == fromList ((3, "B3") :| [(5, "A3"), (7, "C")])
--   </pre>
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
--   
--   <pre>
--   elems (fromList ((5,"a") :| [(3,"b")])) == ("b" :| ["a"])
--   </pre>
elems :: NEMap k a -> NonEmpty a

-- | <i>O(1)</i>. The number of elements in the map. Guaranteed to be
--   greater than zero.
--   
--   <pre>
--   size (singleton 1 'a')                          == 1
--   size (fromList ((1,'a') :| [(2,'c'), (3,'b')])) == 3
--   </pre>
size :: NEMap k a -> Int

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the map in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toMap (fromList ((3,"a") :| [(5,"b")])) == Data.Map.fromList [(3,"a"), (5,"b")]
--   </pre>
toMap :: NEMap k a -> Map k a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A version of <a>foldr</a> that uses the value at the
--   maximal key in the map as the starting value.
--   
--   Note that, unlike <a>foldr1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldr1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly greater than</i> the new key. That is, the new key must be
--   <i>strictly less than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.Map.insert</tt>, it
--   saves a constant factor for key comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the key type.
insertMinMap :: k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly less than</i> the new key. That is, the new key must be
--   <i>strictly greater than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.Map.insert</tt>, it
--   saves a constant factor for key comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the key type.
insertMaxMap :: k -> a -> Map k a -> Map k a

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.NonEmpty.Internal.NEMap k a)
instance Data.Functor.Classes.Eq2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Eq k => Data.Functor.Classes.Eq1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Ord2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Show2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k) => Data.Functor.Classes.Read1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read e) => GHC.Read.Read (Data.Map.NonEmpty.Internal.NEMap k e)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.NonEmpty.Internal.NEMap k a)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.NonEmpty.Internal.NEMap k a)
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Base.Functor (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Foldable.Foldable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Traversable.Traversable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Map.NonEmpty.Internal.NEMap k)


-- | Unsafe internal-use functions used in the implementation of
--   <a>Data.Set.NonEmpty</a>. These functions can potentially be used to
--   break the abstraction of <a>NESet</a> and produce unsound sets, so be
--   wary!
module Data.Set.NonEmpty.Internal

-- | A non-empty set of values <tt>a</tt>. At least one value exists in an
--   <tt><a>NESet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NESet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NESet</a> provide an assurance that
--   the result has at least one item.
--   
--   <a>Data.Set.NonEmpty</a> re-exports the API of <a>Data.Set</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NESet</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Set</a> instead.
--   
--   You can directly construct an <a>NESet</a> with the API from
--   <a>Data.Set.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Set</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NESet</a> from a <a>Set</a>:
--   
--   <ol>
--   <li>The <a>nonEmptySet</a> smart constructor will convert a
--   <tt><a>Set</a> a</tt> into a <tt><a>Maybe</a> (<a>NESet</a> a)</tt>,
--   returning <a>Nothing</a> if the original <a>Set</a> was empty.</li>
--   <li>You can use the <a>insertSet</a> family of functions to insert a
--   value into a <a>Set</a> to create a guarunteed <a>NESet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Set</a> to reveal it as either containing a
--   <a>NESet</a> or an empty map.</li>
--   <li><a>withNESet</a> offers a continuation-based interface for
--   deconstructing a <a>Set</a> and treating it as if it were an
--   <a>NESet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NESet</a> into a <a>Set</a> with <a>toSet</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NESet a
NESet :: !a -> !Set a -> NESet a

-- | invariant: must be smaller than smallest value in set
[nesV0] :: NESet a -> !a
[nesSet] :: NESet a -> !Set a

-- | <i>O(log n)</i>. Smart constructor for an <a>NESet</a> from a
--   <a>Set</a>. Returns <a>Nothing</a> if the <a>Set</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NESet</a>, if
--   the <a>Set</a> was not empty.
--   
--   <a>nonEmptySet</a> and <tt><a>maybe</a> <a>empty</a> <a>toSet</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Set</a> being an <a>NESet</a>.
--   
--   <pre>
--   nonEmptySet (Data.Set.fromList [3,5]) == fromList (3:|[5])
--   </pre>
nonEmptySet :: Set a -> Maybe (NESet a)

-- | <i>O(log n)</i>. Convert a non-empty set back into a normal
--   possibly-empty map, for usage with functions that expect <a>Set</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the set in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptySet</a> and <tt><a>maybe</a> <a>empty</a> <a>toSet</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toSet (fromList ((3,"a") :| [(5,"b")])) == Data.Set.fromList [(3,"a"), (5,"b")]
--   </pre>
toSet :: NESet a -> Set a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: a -> NESet a

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: Ord a => NonEmpty a -> NESet a

-- | <i>O(n)</i>. Convert the set to a non-empty list of elements.
toList :: NESet a -> NonEmpty a

-- | <i>O(1)</i>. The number of elements in the set. Guaranteed to be
--   greater than zero.
size :: NESet a -> Int

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The union of two sets, preferring
--   the first set when equal elements are encountered.
union :: Ord a => NESet a -> NESet a -> NESet a

-- | The union of a non-empty list of sets
unions :: (Foldable1 f, Ord a) => f (NESet a) -> NESet a

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elemsList set = foldr (:) [] set
--   </pre>
foldr :: (a -> b -> b) -> b -> NESet a -> b

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   descElemsList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> b -> a) -> a -> NESet b -> a

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NESet a -> b

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NESet b -> a

-- | Unsafely merge two disjoint sets. Only legal if all items in the first
--   set are less than all items in the second set
merge :: NESet a -> NESet a -> NESet a

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: Ord a => NESet a -> Bool

-- | <i>O(log n)</i>. Insert new value into a set where values are
--   <i>strictly greater than</i> the new values That is, the new value
--   must be <i>strictly less than</i> all values present in the
--   <a>Set</a>. /The precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.Set.insert</tt>, it
--   saves a constant factor for value comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the value type.
insertMinSet :: a -> Set a -> Set a

-- | <i>O(log n)</i>. Insert new value into a set where values are
--   /strictly less than<i> the new value. That is, the new value must be
--   </i>strictly greater than<i> all values present in the <a>Set</a>.
--   </i>The precondition is not checked./
--   
--   While this has the same asymptotics as <tt>Data.Set.insert</tt>, it
--   saves a constant factor for value comparison (so may be helpful if
--   comparison is expensive) and also does not require an <a>Ord</a>
--   instance for the value type.
insertMaxSet :: a -> Set a -> Set a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Set.NonEmpty.Internal.NESet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Set.NonEmpty.Internal.NESet a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Set.NonEmpty.Internal.NESet a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Set.NonEmpty.Internal.NESet a)
instance Data.Functor.Classes.Eq1 Data.Set.NonEmpty.Internal.NESet
instance Data.Functor.Classes.Ord1 Data.Set.NonEmpty.Internal.NESet
instance Data.Functor.Classes.Show1 Data.Set.NonEmpty.Internal.NESet
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Set.NonEmpty.Internal.NESet a)
instance (Data.Data.Data a, GHC.Classes.Ord a) => Data.Data.Data (Data.Set.NonEmpty.Internal.NESet a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Set.NonEmpty.Internal.NESet a)
instance Data.Foldable.Foldable Data.Set.NonEmpty.Internal.NESet
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Set.NonEmpty.Internal.NESet


-- | <h1>Non-Empty Finite Sets</h1>
--   
--   The <tt><a>NESet</a> e</tt> type represents a non-empty set of
--   elements of type <tt>e</tt>. Most operations require that <tt>e</tt>
--   be an instance of the <a>Ord</a> class. A <a>NESet</a> is strict in
--   its elements.
--   
--   See documentation for <a>NESet</a> for information on how to convert
--   and manipulate such non-empty set.
--   
--   This module essentially re-imports the API of <a>Data.Set</a> and its
--   <a>Set</a> type, along with semantics and asymptotics. In most
--   situations, asymptotics are different only by a constant factor. In
--   some situations, asmyptotics are even better (constant-time instead of
--   log-time). All typeclass constraints are identical to their
--   <a>Data.Set</a> counterparts.
--   
--   Because <a>NESet</a> is implemented using <a>Set</a>, all of the
--   caveats of using <a>Set</a> apply (such as the limitation of the
--   maximum size of sets).
--   
--   All functions take non-empty sets as inputs. In situations where their
--   results can be guarunteed to also be non-empty, they also return
--   non-empty sets. In situations where their results could potentially be
--   empty, <a>Set</a> is returned instead.
--   
--   Some functions (<a>partition</a>, <a>spanAntitone</a>, <a>split</a>)
--   have modified return types to account for possible configurations of
--   non-emptiness.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with <a>Prelude</a> and <a>Data.Set</a> functions:
--   
--   <pre>
--   import qualified Data.Set.NonEmpty as NES
--   </pre>
module Data.Set.NonEmpty

-- | A non-empty set of values <tt>a</tt>. At least one value exists in an
--   <tt><a>NESet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NESet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NESet</a> provide an assurance that
--   the result has at least one item.
--   
--   <a>Data.Set.NonEmpty</a> re-exports the API of <a>Data.Set</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NESet</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Set</a> instead.
--   
--   You can directly construct an <a>NESet</a> with the API from
--   <a>Data.Set.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Set</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NESet</a> from a <a>Set</a>:
--   
--   <ol>
--   <li>The <a>nonEmptySet</a> smart constructor will convert a
--   <tt><a>Set</a> a</tt> into a <tt><a>Maybe</a> (<a>NESet</a> a)</tt>,
--   returning <a>Nothing</a> if the original <a>Set</a> was empty.</li>
--   <li>You can use the <a>insertSet</a> family of functions to insert a
--   value into a <a>Set</a> to create a guarunteed <a>NESet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Set</a> to reveal it as either containing a
--   <a>NESet</a> or an empty map.</li>
--   <li><a>withNESet</a> offers a continuation-based interface for
--   deconstructing a <a>Set</a> and treating it as if it were an
--   <a>NESet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NESet</a> into a <a>Set</a> with <a>toSet</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NESet a

-- | <i>O(1)</i> match, <i>O(log n)</i> usage of contents. The
--   <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow you to treat a
--   <a>Set</a> as if it were either a <tt><a>IsNonEmpty</a> n</tt> (where
--   <tt>n</tt> is a <a>NESet</a>) or an <a>IsEmpty</a>.
--   
--   For example, you can pattern match on a <a>Set</a>:
--   
--   <pre>
--   myFunc :: <a>Set</a> X -&gt; Y
--   myFunc (<a>IsNonEmpty</a> n) =  -- here, the user provided a non-empty set, and <tt>n</tt> is the <a>NESet</a>
--   myFunc <a>IsEmpty</a>        =  -- here, the user provided an empty set
--   </pre>
--   
--   Matching on <tt><a>IsNonEmpty</a> n</tt> means that the original
--   <a>Set</a> was <i>not</i> empty, and you have a verified-non-empty
--   <a>NESet</a> <tt>n</tt> to use.
--   
--   Note that patching on this pattern is <i>O(1)</i>. However, using the
--   contents requires a <i>O(log n)</i> cost that is deferred until after
--   the pattern is matched on (and is not incurred at all if the contents
--   are never used).
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsNonEmpty</a> to
--   convert a <a>NESet</a> back into a <a>Set</a>, obscuring its
--   non-emptiness (see <a>toSet</a>).
pattern IsNonEmpty :: NESet a -> Set a

-- | <i>O(1)</i>. The <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow
--   you to treat a <a>Set</a> as if it were either a <tt><a>IsNonEmpty</a>
--   n</tt> (where <tt>n</tt> is a <a>NESet</a>) or an <a>IsEmpty</a>.
--   
--   Matching on <a>IsEmpty</a> means that the original <a>Set</a> was
--   empty.
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsEmpty</a> as an
--   expression, and it will be interpreted as <a>empty</a>.
--   
--   See <a>IsNonEmpty</a> for more information.
pattern IsEmpty :: Set a

-- | <i>O(log n)</i>. Smart constructor for an <a>NESet</a> from a
--   <a>Set</a>. Returns <a>Nothing</a> if the <a>Set</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NESet</a>, if
--   the <a>Set</a> was not empty.
--   
--   <a>nonEmptySet</a> and <tt><a>maybe</a> <a>empty</a> <a>toSet</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Set</a> being an <a>NESet</a>.
--   
--   <pre>
--   nonEmptySet (Data.Set.fromList [3,5]) == fromList (3:|[5])
--   </pre>
nonEmptySet :: Set a -> Maybe (NESet a)

-- | <i>O(log n)</i>. Convert a non-empty set back into a normal
--   possibly-empty map, for usage with functions that expect <a>Set</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the set in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptySet</a> and <tt><a>maybe</a> <a>empty</a> <a>toSet</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toSet (fromList ((3,"a") :| [(5,"b")])) == Data.Set.fromList [(3,"a"), (5,"b")]
--   </pre>
toSet :: NESet a -> Set a

-- | <i>O(log n)</i>. A general continuation-based way to consume a
--   <a>Set</a> as if it were an <a>NESet</a>. <tt><a>withNESet</a> def
--   f</tt> will take a <a>Set</a>. If set is empty, it will evaluate to
--   <tt>def</tt>. Otherwise, a non-empty set <a>NESet</a> will be fed to
--   the function <tt>f</tt> instead.
--   
--   <pre>
--   <a>nonEmptySet</a> == <a>withNESet</a> <a>Nothing</a> <a>Just</a>
--   </pre>
withNESet :: r -> (NESet a -> r) -> Set a -> r

-- | <i>O(log n)</i>. Convert a <a>Set</a> into an <a>NESet</a> by adding a
--   value. Because of this, we know that the set must have at least one
--   element, and so therefore cannot be empty.
--   
--   See <a>insertSetMin</a> for a version that is constant-time if the new
--   value is <i>strictly smaller than</i> all values in the original set
--   
--   <pre>
--   insertSet 4 (Data.Set.fromList [5, 3]) == fromList (3 :| [4, 5])
--   insertSet 4 Data.Set.empty == singleton 4 "c"
--   </pre>
insertSet :: Ord a => a -> Set a -> NESet a

-- | <i>O(1)</i> Convert a <a>Set</a> into an <a>NESet</a> by adding a
--   value where the value is <i>strictly less than</i> all values in the
--   input set The values in the original map must all be <i>strictly
--   greater than</i> the new value. <i>The precondition is not
--   checked.</i>
--   
--   <pre>
--   insertSetMin 2 (Data.Set.fromList [5, 3]) == fromList (2 :| [3, 5])
--   valid (insertSetMin 2 (Data.Set.fromList [5, 3])) == True
--   valid (insertSetMin 7 (Data.Set.fromList [5, 3])) == False
--   valid (insertSetMin 3 (Data.Set.fromList [5, 3])) == False
--   </pre>
insertSetMin :: a -> Set a -> NESet a

-- | <i>O(1)</i> Convert a <a>Set</a> into an <a>NESet</a> by adding a
--   value where the value is <i>strictly less than</i> all values in the
--   input set The values in the original map must all be <i>strictly
--   greater than</i> the new value. <i>The precondition is not
--   checked.</i>
--   
--   While this has the same asymptotics as <a>insertSet</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
--   
--   <pre>
--   insertSetMin 7 (Data.Set.fromList [5, 3]) == fromList (3 :| [5, 7])
--   valid (insertSetMin 7 (Data.Set.fromList [5, 3])) == True
--   valid (insertSetMin 2 (Data.Set.fromList [5, 3])) == False
--   valid (insertSetMin 5 (Data.Set.fromList [5, 3])) == False
--   </pre>
insertSetMax :: a -> Set a -> NESet a

-- | <i>O(log n)</i>. Unsafe version of <a>nonEmptySet</a>. Coerces a
--   <a>Set</a> into an <a>NESet</a>, but is undefined (throws a runtime
--   exception when evaluation is attempted) for an empty <a>Set</a>.
unsafeFromSet :: Set a -> NESet a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: a -> NESet a

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: Ord a => NonEmpty a -> NESet a

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. /The
--   precondition (input list is ascending) is not checked./
fromAscList :: Eq a => NonEmpty a -> NESet a

-- | <i>O(n)</i>. Build a set from a descending list in linear time. <i>The
--   precondition (input list is descending) is not checked.</i>
fromDescList :: Eq a => NonEmpty a -> NESet a

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: NonEmpty a -> NESet a

-- | <i>O(n)</i>. Build a set from a descending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly
--   descending) is not checked.</i>
fromDistinctDescList :: NonEmpty a -> NESet a

-- | Calculate the power set of a non-empty: the set of all its (non-empty)
--   subsets.
--   
--   <pre>
--   t `<a>member</a>` powerSet s == t `<a>isSubsetOf</a>` s
--   </pre>
--   
--   Example:
--   
--   <pre>
--   powerSet (fromList (1 :| [2,3])) =
--     fromList (singleton 1 :| [ singleton 2
--                              , singleton 3
--                              , fromList (1 :| [2])
--                              , fromList (1 :| [3])
--                              , fromList (2 :| [3])
--                              , fromList (1 :| [2,3])
--                              ]
--              )
--   </pre>
--   
--   We know that the result is non-empty because the result will always at
--   least contain the original set.
powerSet :: forall a. () => NESet a -> NESet (NESet a)

-- | <i>O(log n)</i>. Insert an element in a set. If the set already
--   contains an element equal to the given value, it is replaced with the
--   new value.
insert :: Ord a => a -> NESet a -> NESet a

-- | <i>O(log n)</i>. Delete an element from a set.
delete :: Ord a => a -> NESet a -> Set a

-- | <i>O(log n)</i>. Is the element in the set?
member :: Ord a => a -> NESet a -> Bool

-- | <i>O(log n)</i>. Is the element not in the set?
notMember :: Ord a => a -> NESet a -> Bool

-- | <i>O(log n)</i>. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList (3 :| [5])) == Nothing
--   lookupLT 5 (fromList (3 :| [5])) == Just 3
--   </pre>
lookupLT :: Ord a => a -> NESet a -> Maybe a

-- | <i>O(log n)</i>. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupLT 4 (fromList (3 :| [5])) == Just 5
--   lookupLT 5 (fromList (3 :| [5])) == Nothing
--   </pre>
lookupGT :: Ord a => a -> NESet a -> Maybe a

-- | <i>O(log n)</i>. Find largest element smaller or equal to the given
--   one.
--   
--   <pre>
--   lookupLT 2 (fromList (3 :| [5])) == Nothing
--   lookupLT 4 (fromList (3 :| [5])) == Just 3
--   lookupLT 5 (fromList (3 :| [5])) == Just 5
--   </pre>
lookupLE :: Ord a => a -> NESet a -> Maybe a

-- | <i>O(log n)</i>. Find smallest element greater or equal to the given
--   one.
--   
--   <pre>
--   lookupLT 3 (fromList (3 :| [5])) == Just 3
--   lookupLT 4 (fromList (3 :| [5])) == Just 5
--   lookupLT 6 (fromList (3 :| [5])) == Nothing
--   </pre>
lookupGE :: Ord a => a -> NESet a -> Maybe a

-- | <i>O(1)</i>. The number of elements in the set. Guaranteed to be
--   greater than zero.
size :: NESet a -> Int

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Ord a => NESet a -> NESet a -> Bool

-- | <i>O(n+m)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Ord a => NESet a -> NESet a -> Bool

-- | <i>O(n+m)</i>. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList (2:|[4,6]))   (fromList (1:|[3]))     == True
--   disjoint (fromList (2:|[4,6,8])) (fromList (2:|[3,5,7])) == False
--   disjoint (fromList (1:|[2]))     (fromList (1:|[2,3,4])) == False
--   </pre>
disjoint :: Ord a => NESet a -> NESet a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The union of two sets, preferring
--   the first set when equal elements are encountered.
union :: Ord a => NESet a -> NESet a -> NESet a

-- | The union of a non-empty list of sets
unions :: (Foldable1 f, Ord a) => f (NESet a) -> NESet a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Difference of two sets.
--   
--   Returns a potentially empty set (<a>Set</a>) because the first set
--   might be a subset of the second set, and therefore have all of its
--   elements removed.
difference :: Ord a => NESet a -> NESet a -> Set a

-- | Same as <a>difference</a>.
(\\) :: Ord a => NESet a -> NESet a -> Set a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The intersection of two sets.
--   
--   Returns a potentially empty set (<a>Set</a>), because the two sets
--   might have an empty intersection.
--   
--   Elements of the result come from the first set, so for example
--   
--   <pre>
--   import qualified Data.Set.NonEmpty as NES
--   data AB = A | B deriving Show
--   instance Ord AB where compare _ _ = EQ
--   instance Eq AB where _ == _ = True
--   main = print (NES.singleton A `NES.intersection` NES.singleton B,
--                 NES.singleton B `NES.intersection` NES.singleton A)
--   </pre>
--   
--   prints <tt>(fromList (A:|[]),fromList (B:|[]))</tt>.
intersection :: Ord a => NESet a -> NESet a -> Set a

-- | Calculate the Cartesian product of two sets.
--   
--   <pre>
--   cartesianProduct xs ys = fromList $ liftA2 (,) (toList xs) (toList ys)
--   </pre>
--   
--   Example:
--   
--   <pre>
--   cartesianProduct (fromList (1:|[2])) (fromList (<tt>a</tt>:|[<tt>b</tt>])) =
--     fromList ((1,<tt>a</tt>) :| [(1,<tt>b</tt>), (2,<tt>a</tt>), (2,<tt>b</tt>)])
--   </pre>
cartesianProduct :: NESet a -> NESet b -> NESet (a, b)

-- | Calculate the disjoint union of two sets.
--   
--   <pre>
--   disjointUnion xs ys = map Left xs `<a>union</a>` map Right ys
--   </pre>
--   
--   Example:
--   
--   <pre>
--   disjointUnion (fromList (1:|[2])) (fromList ("hi":|["bye"])) =
--     fromList (Left 1 :| [Left 2, Right "hi", Right "bye"])
--   </pre>
disjointUnion :: NESet a -> NESet b -> NESet (Either a b)

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
--   
--   Returns a potentially empty set (<a>Set</a>) because the predicate
--   might filter out all items in the original non-empty set.
filter :: (a -> Bool) -> NESet a -> Set a

-- | <i>O(log n)</i>. Take while a predicate on the elements holds. The
--   user is responsible for ensuring that for all elements <tt>j</tt> and
--   <tt>k</tt> in the set, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See
--   note at <a>spanAntitone</a>.
--   
--   Returns a potentially empty set (<a>Set</a>) because the predicate
--   might fail on the first input.
--   
--   <pre>
--   takeWhileAntitone p = Data.Set.fromDistinctAscList . Data.List.NonEmpty.takeWhile p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (a -> Bool) -> NESet a -> Set a

-- | <i>O(log n)</i>. Drop while a predicate on the elements holds. The
--   user is responsible for ensuring that for all elements <tt>j</tt> and
--   <tt>k</tt> in the set, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See
--   note at <a>spanAntitone</a>.
--   
--   Returns a potentially empty set (<a>Set</a>) because the predicate
--   might be true for all items.
--   
--   <pre>
--   dropWhileAntitone p = Data.Set.fromDistinctAscList . Data.List.NonEmpty.dropWhile p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (a -> Bool) -> NESet a -> Set a

-- | <i>O(log n)</i>. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all elements <tt>j</tt> and <tt>k</tt> in the set, <tt>j &lt; k ==&gt;
--   p j &gt;= p k</tt>.
--   
--   Returns a <a>These</a> with potentially two non-empty sets:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate never failed for
--   any item, returning the original set</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate failed for the
--   first item, returning the original set</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the set up to the
--   point where the predicate stops holding) and <tt>n2</tt> (the set
--   starting from the point where the predicate stops holding)</li>
--   </ul>
--   
--   <pre>
--   spanAntitone p xs = partition p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point where the predicate switches from holding to not holding (where
--   the predicate is seen to hold before the first element and to fail
--   after the last element).
spanAntitone :: (a -> Bool) -> NESet a -> These (NESet a) (NESet a)

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two non-empty sets:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; 3) (fromList (5 :| [3])) == These (singleton 5) (singleton 3)
--   partition (&lt; 7) (fromList (5 :| [3])) == This  (fromList (3 :| [5]))
--   partition (&gt; 7) (fromList (5 :| [3])) == That  (fromList (3 :| [5]))
--   </pre>
partition :: (a -> Bool) -> NESet a -> These (NESet a) (NESet a)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> x set</tt>) is
--   potentially a <a>These</a> containing up to two <a>NESet</a>s based on
--   splitting the set into sets containing items before and after the
--   value <tt>x</tt>. It will never return a set that contains <tt>x</tt>
--   itself.
--   
--   <ul>
--   <li><a>Nothing</a> means that <tt>x</tt> was the only value in the the
--   original set, and so there are no items before or after it.</li>
--   <li><tt><a>Just</a> (<a>This</a> n1)</tt> means <tt>x</tt> was larger
--   than or equal to all items in the set, and <tt>n1</tt> is the entire
--   original set (minus <tt>x</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>That</a> n2)</tt> means <tt>x</tt> was smaller
--   than or equal to all items in the set, and <tt>n2</tt> is the entire
--   original set (minus <tt>x</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>These</a> n1 n2)</tt> gives <tt>n1</tt> (the
--   set of all values from the original set less than <tt>x</tt>) and
--   <tt>n2</tt> (the set of all values from the original set greater than
--   <tt>x</tt>).</li>
--   </ul>
--   
--   <pre>
--   split 2 (fromList (5 :| [3])) == Just (That  (fromList (3 :| [5]))      )
--   split 3 (fromList (5 :| [3])) == Just (That  (singleton 5)              )
--   split 4 (fromList (5 :| [3])) == Just (These (singleton 3) (singleton 5))
--   split 5 (fromList (5 :| [3])) == Just (This  (singleton 3)              )
--   split 6 (fromList (5 :| [3])) == Just (This  (fromList (3 :| [5]))      )
--   split 5 (singleton 5)         == Nothing
--   </pre>
split :: Ord a => a -> NESet a -> Maybe (These (NESet a) (NESet a))

-- | <i>O(log n)</i>. The expression (<tt><tt>splitLookup</tt> x set</tt>)
--   splits a set just like <a>split</a> but also returns <tt><a>member</a>
--   x set</tt> (whether or not <tt>x</tt> was in <tt>set</tt>)
--   
--   <pre>
--   splitMember 2 (fromList (5 :| [3])) == (False, Just (That  (fromList (3 :| [5)]))))
--   splitMember 3 (fromList (5 :| [3])) == (True , Just (That  (singleton 5)))
--   splitMember 4 (fromList (5 :| [3])) == (False, Just (These (singleton 3) (singleton 5)))
--   splitMember 5 (fromList (5 :| [3])) == (True , Just (This  (singleton 3))
--   splitMember 6 (fromList (5 :| [3])) == (False, Just (This  (fromList (3 :| [5])))
--   splitMember 5 (singleton 5)         == (True , Nothing)
--   </pre>
splitMember :: Ord a => a -> NESet a -> (Bool, Maybe (These (NESet a) (NESet a)))

-- | <i>O(1)</i>. Decompose a set into pieces based on the structure of the
--   underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first subset less than all elements in the second, and so on).
--   
--   Note that the current implementation does not return more than four
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: NESet a -> NonEmpty (NESet a)

-- | <i>O(log n)</i>. Lookup the <i>index</i> of an element, which is its
--   zero-based index in the sorted sequence of elements. The index is a
--   number from <i>0</i> up to, but not including, the <a>size</a> of the
--   set.
--   
--   <pre>
--   isJust   (lookupIndex 2 (fromList (5:|[3]))) == False
--   fromJust (lookupIndex 3 (fromList (5:|[3]))) == 0
--   fromJust (lookupIndex 5 (fromList (5:|[3]))) == 1
--   isJust   (lookupIndex 6 (fromList (5:|[3]))) == False
--   </pre>
lookupIndex :: Ord a => a -> NESet a -> Maybe Int

-- | <i>O(log n)</i>. Return the <i>index</i> of an element, which is its
--   zero-based index in the sorted sequence of elements. The index is a
--   number from <i>0</i> up to, but not including, the <a>size</a> of the
--   set. Calls <a>error</a> when the element is not a <a>member</a> of the
--   set.
--   
--   <pre>
--   findIndex 2 (fromList (5:|[3]))    Error: element is not in the set
--   findIndex 3 (fromList (5:|[3])) == 0
--   findIndex 5 (fromList (5:|[3])) == 1
--   findIndex 6 (fromList (5:|[3]))    Error: element is not in the set
--   </pre>
findIndex :: Ord a => a -> NESet a -> Int

-- | <i>O(log n)</i>. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sorted sequence of elements. If the
--   <i>index</i> is out of range (less than zero, greater or equal to
--   <a>size</a> of the set), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList (5:|[3])) == 3
--   elemAt 1 (fromList (5:|[3])) == 5
--   elemAt 2 (fromList (5:|[3]))    Error: index out of range
--   </pre>
elemAt :: Int -> NESet a -> a

-- | <i>O(log n)</i>. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sorted sequence of elements. If the
--   <i>index</i> is out of range (less than zero, greater or equal to
--   <a>size</a> of the set), <a>error</a> is called.
--   
--   Returns a potentially empty set (<a>Set</a>), because this could
--   potentailly delete the final element in a singleton set.
--   
--   <pre>
--   deleteAt 0    (fromList (5:|[3])) == singleton 5
--   deleteAt 1    (fromList (5:|[3])) == singleton 3
--   deleteAt 2    (fromList (5:|[3]))    Error: index out of range
--   deleteAt (-1) (fromList (5:|[3]))    Error: index out of range
--   </pre>
deleteAt :: Int -> NESet a -> Set a

-- | Take a given number of elements in order, beginning with the smallest
--   ones.
--   
--   Returns a potentailly empty set (<a>Set</a>), which can only happen
--   when calling <tt>take 0</tt>.
--   
--   <pre>
--   take n = Data.Set.fromDistinctAscList . Data.List.NonEmpty.take n . <a>toAscList</a>
--   </pre>
take :: Int -> NESet a -> Set a

-- | Drop a given number of elements in order, beginning with the smallest
--   ones.
--   
--   Returns a potentailly empty set (<a>Set</a>), in the case that
--   <a>drop</a> is called with a number equal to or greater the number of
--   items in the set, and we drop every item.
--   
--   <pre>
--   drop n = Data.Set.fromDistinctAscList . Data.List.NonEmpty.drop n . <a>toAscList</a>
--   </pre>
drop :: Int -> NESet a -> Set a

-- | <i>O(log n)</i>. Split a set at a particular index <tt>i</tt>.
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that there are less than <tt>i</tt>
--   items in the set, and <tt>n1</tt> is the original set.</li>
--   <li><tt><a>That</a> n2</tt> means <tt>i</tt> was 0; we dropped 0
--   items, so <tt>n2</tt> is the original set.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (taking <tt>i</tt>
--   items from the original set) and <tt>n2</tt> (dropping <tt>i</tt>
--   items from the original set))</li>
--   </ul>
splitAt :: Int -> NESet a -> These (NESet a) (NESet a)

-- | <i>O(n*log n)</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: Ord b => (a -> b) -> NESet a -> NESet b

-- | <i>O(n)</i>. <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but
--   works only when <tt>f</tt> is strictly increasing. <i>The precondition
--   is not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = Data.Foldable.toList s
--   </pre>
mapMonotonic :: (a -> b) -> NESet a -> NESet b

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elemsList set = foldr (:) [] set
--   </pre>
foldr :: (a -> b -> b) -> b -> NESet a -> b

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   descElemsList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> b -> a) -> a -> NESet b -> a

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NESet a -> b

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NESet b -> a

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NESet a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NESet a -> a

-- | <i>O(1)</i>. The minimal element of a set. Note that this is total,
--   making <a>lookupMin</a> obsolete. It is constant-time, so has better
--   asymptotics than <tt>Data.Set.lookupMin</tt> and
--   <tt>Data.Map.findMin</tt> as well.
--   
--   <pre>
--   findMin (fromList (5 :| [3])) == 3
--   </pre>
findMin :: NESet a -> a

-- | <i>O(log n)</i>. The maximal key of a set Note that this is total,
--   making <a>lookupMin</a> obsolete.
--   
--   <pre>
--   findMax (fromList (5 :| [3])) == 5
--   </pre>
findMax :: NESet a -> a

-- | <i>O(1)</i>. Delete the minimal element. Returns a potentially empty
--   set (<a>Set</a>), because we might delete the final item in a
--   singleton set. It is constant-time, so has better asymptotics than
--   <tt>Data.Set.deleteMin</tt>.
--   
--   <pre>
--   deleteMin (fromList (5 :| [3, 7])) == Data.Set.fromList [5, 7]
--   deleteMin (singleton 5) == Data.Set.empty
--   </pre>
deleteMin :: NESet a -> Set a

-- | <i>O(log n)</i>. Delete the maximal element. Returns a potentially
--   empty set (<a>Set</a>), because we might delete the final item in a
--   singleton set.
--   
--   <pre>
--   deleteMax (fromList (5 :| [3, 7])) == Data.Set.fromList [3, 5]
--   deleteMax (singleton 5) == Data.Set.empty
--   </pre>
deleteMax :: NESet a -> Set a

-- | <i>O(1)</i>. Delete and find the minimal element. It is constant-time,
--   so has better asymptotics that <tt>Data.Set.minView</tt> for
--   <a>Set</a>.
--   
--   Note that unlike <tt>Data.Set.deleteFindMin</tt> for <a>Set</a>, this
--   cannot ever fail, and so is a total function. However, the result
--   <a>Set</a> is potentially empty, since the original set might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMin (fromList (5 :| [3, 10])) == (3, Data.Set.fromList [5, 10])
--   </pre>
deleteFindMin :: NESet a -> (a, Set a)

-- | <i>O(log n)</i>. Delete and find the minimal element.
--   
--   Note that unlike <tt>Data.Set.deleteFindMax</tt> for <a>Set</a>, this
--   cannot ever fail, and so is a total function. However, the result
--   <a>Set</a> is potentially empty, since the original set might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMax (fromList (5 :| [3, 10])) == (10, Data.Set.fromList [3, 5])
--   </pre>
deleteFindMax :: NESet a -> (a, Set a)

-- | <i>O(n)</i>. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order.
elems :: NESet a -> NonEmpty a

-- | <i>O(n)</i>. Convert the set to a non-empty list of elements.
toList :: NESet a -> NonEmpty a

-- | <i>O(n)</i>. Convert the set to an ascending non-empty list of
--   elements.
toAscList :: NESet a -> NonEmpty a

-- | <i>O(n)</i>. Convert the set to a descending non-empty list of
--   elements.
toDescList :: NESet a -> NonEmpty a

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: Ord a => NESet a -> Bool
instance GHC.Base.Semigroup (Data.Set.NonEmpty.MergeNESet a)


-- | <h1>Non-Empty Finite Maps (lazy interface)</h1>
--   
--   The <tt><a>NEMap</a> k v</tt> type represents a non-empty finite map
--   (sometimes called a dictionary) from keys of type <tt>k</tt> to values
--   of type <tt>v</tt>. An <a>NEMap</a> is strict in its keys but lazy in
--   its values.
--   
--   See documentation for <a>NEMap</a> for information on how to convert
--   and manipulate such non-empty maps.
--   
--   This module essentially re-imports the API of <a>Data.Map.Lazy</a> and
--   its <a>Map</a> type, along with semantics and asymptotics. In most
--   situations, asymptotics are different only by a constant factor. In
--   some situations, asmyptotics are even better (constant-time instead of
--   log-time). All typeclass constraints are identical to their
--   <a>Data.Map</a> counterparts.
--   
--   Because <a>NEMap</a> is implemented using <a>Map</a>, all of the
--   caveats of using <a>Map</a> apply (such as the limitation of the
--   maximum size of maps).
--   
--   All functions take non-empty maps as inputs. In situations where their
--   results can be guarunteed to also be non-empty, they also return
--   non-empty maps. In situations where their results could potentially be
--   empty, <a>Map</a> is returned instead.
--   
--   Some variants of functions (like <a>alter'</a>, <a>alterF'</a>,
--   <a>adjustAt</a>, <a>adjustMin</a>, <a>adjustMax</a>,
--   <a>adjustMinWithKey</a>, <a>adjustMaxWithKey</a>) are provided in a
--   way restructured to preserve guaruntees of non-empty maps being
--   returned.
--   
--   Some functions (like <a>mapEither</a>, <a>partition</a>,
--   <a>spanAntitone</a>, <a>split</a>) have modified return types to
--   account for possible configurations of non-emptiness.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with <a>Prelude</a> and <a>Data.Map</a> functions:
--   
--   <pre>
--   import qualified Data.Map.NonEmpty as NEM
--   </pre>
module Data.Map.NonEmpty

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNEMap</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a <a>Map</a> with <a>toMap</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NEMap k a

-- | <i>O(1)</i> match, <i>O(log n)</i> usage of contents. The
--   <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow you to treat a
--   <a>Map</a> as if it were either a <tt><a>IsNonEmpty</a> n</tt> (where
--   <tt>n</tt> is a <a>NEMap</a>) or an <a>IsEmpty</a>.
--   
--   For example, you can pattern match on a <a>Map</a>:
--   
--   <pre>
--   myFunc :: <a>Map</a> K X -&gt; Y
--   myFunc (<a>IsNonEmpty</a> n) =  -- here, the user provided a non-empty map, and <tt>n</tt> is the <a>NEMap</a>
--   myFunc <a>IsEmpty</a>        =  -- here, the user provided an empty map.
--   </pre>
--   
--   Matching on <tt><a>IsNonEmpty</a> n</tt> means that the original
--   <a>Map</a> was <i>not</i> empty, and you have a verified-non-empty
--   <a>NEMap</a> <tt>n</tt> to use.
--   
--   Note that patching on this pattern is <i>O(1)</i>. However, using the
--   contents requires a <i>O(log n)</i> cost that is deferred until after
--   the pattern is matched on (and is not incurred at all if the contents
--   are never used).
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsNonEmpty</a> to
--   convert a <a>NEMap</a> back into a <a>Map</a>, obscuring its
--   non-emptiness (see <a>toMap</a>).
pattern IsNonEmpty :: NEMap k a -> Map k a

-- | <i>O(1)</i>. The <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow
--   you to treat a <a>Map</a> as if it were either a <tt><a>IsNonEmpty</a>
--   n</tt> (where <tt>n</tt> is a <a>NEMap</a>) or an <a>IsEmpty</a>.
--   
--   Matching on <a>IsEmpty</a> means that the original <a>Map</a> was
--   empty.
--   
--   A case statement handling both <a>IsNonEmpty</a> and <a>IsEmpty</a>
--   provides complete coverage.
--   
--   This is a bidirectional pattern, so you can use <a>IsEmpty</a> as an
--   expression, and it will be interpreted as <a>empty</a>.
--   
--   See <a>IsNonEmpty</a> for more information.
pattern IsEmpty :: Map k a

-- | <i>O(log n)</i>. Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Map</a> being an <a>NEMap</a>.
--   
--   <pre>
--   nonEmptyMap (Data.Map.fromList [(3,"a"), (5,"b")]) == fromList ((3,"a") :| [(5,"b")])
--   </pre>
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the map in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toMap (fromList ((3,"a") :| [(5,"b")])) == Data.Map.fromList [(3,"a"), (5,"b")]
--   </pre>
toMap :: NEMap k a -> Map k a

-- | <i>O(log n)</i>. A general continuation-based way to consume a
--   <a>Map</a> as if it were an <a>NEMap</a>. <tt><a>withNEMap</a> def
--   f</tt> will take a <a>Map</a>. If map is empty, it will evaluate to
--   <tt>def</tt>. Otherwise, a non-empty map <a>NEMap</a> will be fed to
--   the function <tt>f</tt> instead.
--   
--   <pre>
--   <a>nonEmptyMap</a> == <a>withNEMap</a> <a>Nothing</a> <a>Just</a>
--   </pre>
withNEMap :: r -> (NEMap k a -> r) -> Map k a -> r

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. If key is already
--   present, will overwrite the original value.
--   
--   See <a>insertMapMin</a> for a version that is constant-time if the new
--   key is <i>strictly smaller than</i> all keys in the original map.
--   
--   <pre>
--   insertMap 4 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(4,"c"), (5,"a")])
--   insertMap 4 "c" Data.Map.empty == singleton 4 "c"
--   </pre>
insertMap :: Ord k => k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. Uses a combining
--   function with the new value as the first argument if the key is
--   already present.
--   
--   <pre>
--   insertMapWith (++) 4 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(4,"c"), (5,"a")])
--   insertMapWith (++) 5 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(5,"ca")])
--   </pre>
insertMapWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. Uses a combining
--   function with the key and new value as the first and second arguments
--   if the key is already present.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3, "b") :| [(5, "5:xxx|a")])
--   insertWithKey f 7 "xxx" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   insertWithKey f 5 "xxx" Data.Map.empty                         == singleton 5 "xxx"
--   </pre>
insertMapWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(1)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly less than</i> all keys in
--   the input map. The keys in the original map must all be <i>strictly
--   greater than</i> the new key. <i>The precondition is not checked.</i>
--   
--   <pre>
--   insertMapMin 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((2,"c") :| [(3,"b"), (5,"a")])
--   valid (insertMapMin 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == True
--   valid (insertMapMin 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   valid (insertMapMin 3 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   </pre>
insertMapMin :: k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly greater than</i> all keys
--   in the input map. The keys in the original map must all be <i>strictly
--   less than</i> the new key. <i>The precondition is not checked.</i>
--   
--   While this has the same asymptotics as <a>insertMap</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
--   
--   <pre>
--   insertMap 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(5,"a"), (7,"c")])
--   valid (insertMap 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == True
--   valid (insertMap 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   valid (insertMap 5 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   </pre>
insertMapMax :: k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Unsafe version of <a>nonEmptyMap</a>. Coerces a
--   <a>Map</a> into an <a>NEMap</a>, but is undefined (throws a runtime
--   exception when evaluation is attempted) for an empty <a>Map</a>.
unsafeFromMap :: Map k a -> NEMap k a

-- | <i>O(1)</i>. A map with a single element.
--   
--   <pre>
--   singleton 1 'a'        == fromList ((1, 'a') :| [])
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: k -> a -> NEMap k a

-- | <i>O(n)</i>. Build a non-empty map from a non-empty set of keys and a
--   function which for each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Set.NonEmpty.fromList (3 :| [5])) == fromList ((5,"aaaaa") :| [(3,"aaa")])
--   </pre>
fromSet :: (k -> a) -> NESet k -> NEMap k a

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <a>fromAscList</a>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
--   
--   <pre>
--   fromList ((5,"a") :| [(3,"b"), (5, "c")]) == fromList ((5,"c") :| [(3,"b")])
--   fromList ((5,"c") :| [(3,"b"), (5, "a")]) == fromList ((5,"a") :| [(3,"b")])
--   </pre>
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n*log n)</i>. Build a map from a non-empty list of key/value
--   pairs with a combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) ((5,"a") :| [(5,"b"), (3,"b"), (3,"a"), (5,"a")]) == fromList ((3, "ab") :| [(5, "aba")])
--   </pre>
fromListWith :: Ord k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n*log n)</i>. Build a map from a non-empty list of key/value
--   pairs with a combining function. See also <a>fromAscListWithKey</a>.
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ a1 ++ a2
--   fromListWithKey f ((5,"a") :| [(5,"b"), (3,"b"), (3,"a"), (5,"a")]) == fromList ((3, "3ab") :| [(5, "5a5ba")])
--   </pre>
fromListWithKey :: Ord k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time. <i>The precondition (input list is ascending) is not
--   checked.</i>
--   
--   <pre>
--   fromAscList ((3,"b") :| [(5,"a")])          == fromList ((3, "b") :| [(5, "a")])
--   fromAscList ((3,"b") :| [(5,"a"), (5,"b")]) == fromList ((3, "b") :| [(5, "b")])
--   valid (fromAscList ((3,"b") :| [(5,"a"), (5,"b")])) == True
--   valid (fromAscList ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromAscList :: Eq k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is ascending) is not checked./
--   
--   <pre>
--   fromAscListWith (++) ((3,"b") :| [(5,"a"), (5,"b")]) == fromList ((3, "b") :| [(5, "ba")])
--   valid (fromAscListWith (++) ((3,"b") :| [(5,"a"), (5,"b"))]) == True
--   valid (fromAscListWith (++) ((5,"a") :| [(3,"b"), (5,"b"))]) == False
--   </pre>
fromAscListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is ascending) is not checked./
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromAscListWithKey f ((3,"b") :| [(5,"a"), (5,"b"), (5,"b")]) == fromList ((3, "b") :| [(5, "5:b5:ba")])
--   valid (fromAscListWithKey f ((3,"b") :| [(5,"a"), (5,"b"), (5,"b")])) == True
--   valid (fromAscListWithKey f ((5,"a") :| [(3,"b"), (5,"b"), (5,"b")])) == False
--   </pre>
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list of distinct
--   elements in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList ((3,"b") :| [(5,"a")]) == fromList ((3, "b") :| [(5, "a")])
--   valid (fromDistinctAscList ((3,"b") :| [(5,"a")]))          == True
--   valid (fromDistinctAscList ((3,"b") :| [(5,"a"), (5,"b")])) == False
--   </pre>
fromDistinctAscList :: NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time. <i>The precondition (input list is descending) is not
--   checked.</i>
--   
--   <pre>
--   fromDescList ((5,"a") :| [(3,"b")])          == fromList ((3, "b") :| [(5, "a")])
--   fromDescList ((5,"a") :| [(5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "b")])
--   valid (fromDescList ((5,"a") :| [(5,"b"), (3,"b")])) == True
--   valid (fromDescList ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromDescList :: Eq k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is descending) is not checked./
--   
--   <pre>
--   fromDescListWith (++) ((5,"a") :| [(5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "ba")])
--   valid (fromDescListWith (++) ((5,"a") :| [(5,"b"), (3,"b")])) == True
--   valid (fromDescListWith (++) ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromDescListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is descending) is not checked./
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromDescListWithKey f ((5,"a") :| [(5,"b"), (5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "5:b5:ba")])
--   valid (fromDescListWithKey f ((5,"a") :| [(5,"b"), (5,"b"), (3,"b")])) == True
--   valid (fromDescListWithKey f ((5,"a") :| [(3,"b"), (5,"b"), (5,"b")])) == False
--   </pre>
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctDescList ((5,"a") :| [(3,"b")]) == fromList ((3, "b") :| [(5, "a")])
--   valid (fromDistinctDescList ((5,"a") :| [(3,"b")]))          == True
--   valid (fromDistinctDescList ((5,"a") :| [(5,"b"), (3,"b")])) == False
--   </pre>
fromDistinctDescList :: NonEmpty (k, a) -> NEMap k a

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   See <a>insertMap</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insert 5 'x' (fromList ((5,'a') :| [(3,'b')])) == fromList ((3, 'b') :| [(5, 'x')])
--   insert 7 'x' (fromList ((5,'a') :| [(3,'b')])) == fromList ((3, 'b') :| [(5, 'a'), (7, 'x')])
--   </pre>
insert :: Ord k => k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   See <a>insertMapWith</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "xxxa")])
--   insertWith (++) 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Insert with a function, combining key, new value and
--   old value. <tt><a>insertWithKey</a> f key value mp</tt> will insert
--   the pair (key, value) into <tt>mp</tt> if key does not exist in the
--   map. If the key does exist, the function will insert the pair
--   <tt>(key,f key new_value old_value)</tt>. Note that the key passed to
--   f is the same key passed to <a>insertWithKey</a>.
--   
--   See <a>insertMapWithKey</a> for a version where the first argument is
--   a <a>Map</a>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "5:xxx|a")])
--   insertWithKey f 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Combines insert operation with old value retrieval.
--   The expression (<tt><a>insertLookupWithKey</a> f k x map</tt>) is a
--   pair where the first element is equal to (<tt><a>lookup</a> k
--   map</tt>) and the second element equal to (<tt><a>insertWithKey</a> f
--   k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == (Just "a", fromList ((3, "b") :| [(5, "5:xxx|a")]))
--   insertLookupWithKey f 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == (Nothing,  fromList ((3, "b") :| [(5, "a"), (7, "xxx")]))
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList ((5,"a") :| [(3,"b")])) == (Just "a", fromList ((3, "b") :| [(5, "x")]))
--   insertLookup 7 "x" (fromList ((5,"a") :| [(3,"b")])) == (Nothing,  fromList ((3, "b") :| [(5, "a"), (7, "x")]))
--   </pre>
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> (Maybe a, NEMap k a)

-- | <i>O(log n)</i>. Delete a key and its value from the non-empty map. A
--   potentially empty map (<a>Map</a>) is returned, since this might
--   delete the last item in the <a>NEMap</a>. When the key is not a member
--   of the map, is equivalent to <a>toMap</a>.
--   
--   <pre>
--   delete 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   delete 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.Singleton [(3, "b"), (5, "a")]
--   </pre>
delete :: Ord k => k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update a value at a specific key with the result of
--   the provided function. When the key is not a member of the map, the
--   original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "new a")])
--   adjust ("new " ++) 7 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a")])
--   </pre>
adjust :: Ord k => (a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "5:new a")])
--   adjustWithKey f 7 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a")])
--   </pre>
adjustWithKey :: Ord k => (k -> a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. The expression (<tt><a>update</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
update :: Ord k => (a -> Maybe a) -> k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k
--   map</tt>) updates the value <tt>x</tt> at <tt>k</tt> (if it is in the
--   map). If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted.
--   If it is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the
--   new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k
--   map</tt>) updates the value <tt>x</tt> at <tt>k</tt> (if it is in the
--   map). If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted.
--   If it is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the
--   new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> (Maybe a, Map k a)

-- | <i>O(log n)</i>. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <a>Map</a>. In
--   short : <tt>Data.Map.lookup k (<a>alter</a> f k m) = f (<a>lookup</a>
--   k m)</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   See <a>alterF'</a> for a version that disallows deletion, and so
--   therefore can return <a>NEMap</a>.
--   
--   <pre>
--   let f _ = Nothing
--   alter f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   alter f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   
--   let f _ = Just "c"
--   alter f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a"), (7, "c")]
--   alter f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "c")]
--   </pre>
alter :: Ord k => (Maybe a -> Maybe a) -> k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>alterF</a> f k map</tt>)
--   alters the value <tt>x</tt> at <tt>k</tt>, or absence thereof.
--   <a>alterF</a> can be used to inspect, insert, delete, or update a
--   value in a <a>Map</a>. In short: <tt>Data.Map.lookup k &lt;$&gt;
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; NEMap Int String -&gt; IO (Map Int String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   Like <tt>Data.Map.alterF</tt> for <a>Map</a>, <a>alterF</a> can be
--   considered to be a unifying generalization of <a>lookup</a> and
--   <a>delete</a>; however, as a constrast, it cannot be used to implement
--   <a>insert</a>, because it must return a <a>Map</a> instead of an
--   <a>NEMap</a> (because the function might delete the final item in the
--   <a>NEMap</a>). When used with trivial functors like <a>Identity</a>
--   and <a>Const</a>, it is often slightly slower than specialized
--   <a>lookup</a> and <a>delete</a>. However, when the functor is
--   non-trivial and key comparison is not particularly cheap, it is the
--   fastest way.
--   
--   See <a>alterF'</a> for a version that disallows deletion, and so
--   therefore can return <a>NEMap</a> and be used to implement
--   <a>insert</a>
--   
--   Note on rewrite rules:
--   
--   This module includes GHC rewrite rules to optimize <a>alterF</a> for
--   the <a>Const</a> and <a>Identity</a> functors. In general, these rules
--   improve performance. The sole exception is that when using
--   <a>Identity</a>, deleting a key that is already absent takes longer
--   than it would without the rules. If you expect this to occur a very
--   large fraction of the time, you might consider using a private copy of
--   the <a>Identity</a> type.
--   
--   Note: Unlike <tt>Data.Map.alterF</tt> for <a>Map</a>, <a>alterF</a> is
--   <i>not</i> a flipped version of the <a>at</a> combinator from
--   <a>Control.Lens.At</a>. However, it match the shape expected from most
--   functions expecting lenses, getters, and setters, so can be thought of
--   as a "psuedo-lens", with virtually the same practical applications as
--   a legitimate lens.
alterF :: (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> NEMap k a -> f (Map k a)

-- | <i>O(log n)</i>. Variant of <a>alter</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
alter' :: Ord k => (Maybe a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Variant of <a>alterF</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
--   
--   Like <tt>Data.Map.alterF</tt> for <a>Map</a>, can be used to
--   generalize and unify <a>lookup</a> and <a>insert</a>. However, because
--   it disallows deletion, it cannot be used to implement <a>delete</a>.
--   
--   See <a>alterF</a> for usage information and caveats.
--   
--   Note: Neither <a>alterF</a> nor <a>alterF'</a> can be considered
--   flipped versions of the <a>at</a> combinator from
--   <a>Control.Lens.At</a>. However, this can match the shape expected
--   from most functions expecting lenses, getters, and setters, so can be
--   thought of as a "psuedo-lens", with virtually the same practical
--   applications as a legitimate lens.
--   
--   <b>WARNING</b>: The rewrite rule for <a>Identity</a> exposes an
--   inconsistency in undefined behavior for <a>Data.Map</a>.
--   <tt>Data.Map.alterF</tt> will actually <i>maintain</i> the original
--   key in the map when used with <a>Identity</a>; however,
--   <tt>Data.Map.insertWith</tt> will <i>replace</i> the orginal key in
--   the map. The rewrite rule for <a>alterF'</a> has chosen to be faithful
--   to <tt>Data.Map.insertWith</tt>, and <i>not</i>
--   <tt>Data.Map.alterF</tt>, for the sake of a cleaner implementation.
alterF' :: (Ord k, Functor f) => (Maybe a -> f a) -> k -> NEMap k a -> f (NEMap k a)

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
--   
--   An example of using <tt>lookup</tt>:
--   
--   <pre>
--   import Prelude hiding (lookup)
--   import Data.Map.NonEmpty
--   
--   employeeDept = fromList (("John","Sales") :| [("Bob","IT")])
--   deptCountry = fromList (("IT","USA") :| [("Sales","France")])
--   countryCurrency = fromList (("USA", "Dollar") :| [("France", "Euro")])
--   
--   employeeCurrency :: String -&gt; Maybe String
--   employeeCurrency name = do
--       dept &lt;- lookup name employeeDept
--       country &lt;- lookup dept deptCountry
--       lookup country countryCurrency
--   
--   main = do
--       putStrLn $ "John's currency: " ++ (show (employeeCurrency "John"))
--       putStrLn $ "Pete's currency: " ++ (show (employeeCurrency "Pete"))
--   </pre>
--   
--   The output of this program:
--   
--   <pre>
--   John's currency: Just "Euro"
--   Pete's currency: Nothing
--   </pre>
lookup :: Ord k => k -> NEMap k a -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Returns <a>Nothing</a> when
--   the element can not be found.
--   
--   <pre>
--   fromList ((5, 'a') :| [(3, 'b')]) !? 1 == Nothing
--   </pre>
--   
--   <pre>
--   fromList ((5, 'a') :| [(3, 'b')]) !? 5 == Just 'a'
--   </pre>
(!?) :: Ord k => NEMap k a -> k -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList ((5,'a') :| [(3,'b')]) ! 1    Error: element not in the map
--   fromList ((5,'a') :| [(3,'b')]) ! 5 == 'a'
--   </pre>
(!) :: Ord k => NEMap k a -> k -> a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList ((5,'a') :| [(3,'b')])) == 'x'
--   findWithDefault 'x' 5 (fromList ((5,'a') :| [(3,'b')])) == 'a'
--   </pre>
findWithDefault :: Ord k => a -> k -> NEMap k a -> a

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
--   
--   <pre>
--   member 5 (fromList ((5,'a') :| [(3,'b')])) == True
--   member 1 (fromList ((5,'a') :| [(3,'b')])) == False
--   </pre>
member :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
--   
--   <pre>
--   notMember 5 (fromList ((5,'a') :| [(3,'b')])) == False
--   notMember 1 (fromList ((5,'a') :| [(3,'b')])) == True
--   </pre>
notMember :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Find largest key smaller than the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   lookupLT 4 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   </pre>
lookupLT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater than the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   lookupGT 5 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   </pre>
lookupGT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find largest key smaller or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   lookupLE 4 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   lookupLE 5 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   </pre>
lookupLE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   lookupGE 4 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   lookupGE 6 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   </pre>
lookupGE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(1)</i>. The number of elements in the map. Guaranteed to be
--   greater than zero.
--   
--   <pre>
--   size (singleton 1 'a')                          == 1
--   size (fromList ((1,'a') :| [(2,'c'), (3,'b')])) == 3
--   </pre>
size :: NEMap k a -> Int

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "a"), (7, "C")])
--   </pre>
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "aA"), (7, "C")])
--   </pre>
unionWith :: Ord k => (a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function,
--   given the matching key.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "5:a|A"), (7, "C")])
--   </pre>
unionWithKey :: Ord k => (k -> a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a non-empty list of maps.
--   
--   <pre>
--   unions (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions (fromList ((5, "A3") :| [(3, "B3")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "a") :| [(3, "b")])])
--       == fromList ((3, "B3") :| [(5, "A3"), (7, "C")])
--   </pre>
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | The union of a non-empty list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl1</a> (<a>unionWith</a> f)</tt>).
--   
--   <pre>
--   unionsWith (++) (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList ((3, "bB3") :| [(5, "aAA3"), (7, "C")])
--   </pre>
unionsWith :: (Foldable1 f, Ord k) => (a -> a -> a) -> f (NEMap k a) -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Difference of two maps. Return
--   elements of the first map not existing in the second map.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map.
--   
--   <pre>
--   difference (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 3 "b"
--   </pre>
difference :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | Same as <a>difference</a>.
(\\) :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the values
--   of these keys. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map and the function returns <a>Nothing</a> for
--   every pair.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(3, "B"), (7, "C")]))
--       == Data.Map.singleton 3 "b:B"
--   </pre>
differenceWith :: Ord k => (a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map and the function returns <a>Nothing</a> for
--   every pair.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(3, "B"), (10, "C")]))
--       == Data.Map.singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection of two maps. Return
--   data in the first map for the keys existing in both maps.
--   (<tt><a>intersection</a> m1 m2 == <a>intersectionWith</a> <a>const</a>
--   m1 m2</tt>).
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   intersection (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "a"
--   </pre>
intersection :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   intersectionWith (++) (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "aA"
--   </pre>
intersectionWith :: Ord k => (a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "bx") :| [(5, "ax")])
--   </pre>
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "3:b") :| [(5, "5:a")])
--   </pre>
mapWithKey :: (k -> a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. Traverse keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), our function might
--   return <a>Nothing</a> on every item in the <a>NEMap</a>.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseMaybeWithKey1 :: Apply t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)

-- | <i>O(n)</i>. Traverse keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), our function might
--   return <a>Nothing</a> on every item in the <a>NEMap</a>.
--   
--   <i>Use <a>traverseMaybeWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
traverseMaybeWithKey :: Applicative t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)

-- | <i>O(n)</i>. The function <a>mapAccum</a> threads an accumulating
--   argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList ((5,"a") :| [(3,"b")])) == ("Everything: ba", fromList ((3, "bX") :| [(5, "aX")]))
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n)</i>. The function <a>mapAccumWithKey</a> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList ((5,"a") :| [(3,"b")])) == ("Everything: 3-b 5-a", fromList ((3, "bX") :| [(5, "aX")]))
--   </pre>
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n)</i>. The function <a>mapAccumRWithKey</a> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n*log n)</i>. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeys (+ 1) (fromList ((5,"a") :| [(3,"b")]))                        == fromList ((4, "b") :| [(6, "a")])
--   mapKeys (\ _ -&gt; 1) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 3 "c"
--   </pre>
mapKeys :: Ord k2 => (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n*log n)</i>. <tt><a>mapKeysWith</a> c f s</tt> is the map
--   obtained by applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>. The value at the greater of the two
--   original keys is used as the first argument to <tt>c</tt>.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList ((5,"a") :| [(3,"b")])) == fromList ((6, "b") :| [(10, "a")])
--   valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList ((5,"a") :| [(3,"b")]))) == True
--   valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList ((5,"a") :| [(3,"b")]))) == False
--   </pre>
mapKeysMonotonic :: (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldr</a> that uses the value at the
--   maximal key in the map as the starting value.
--   
--   Note that, unlike <a>foldr1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldr1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
foldrWithKey :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
foldlWithKey :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldrWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldrWithKey' :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldlWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldlWithKey' :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
--   
--   <pre>
--   elems (fromList ((5,"a") :| [(3,"b")])) == ("b" :| ["a"])
--   </pre>
elems :: NEMap k a -> NonEmpty a

-- | <i>O(n)</i>. Return all keys of the map in ascending order.
--   
--   <pre>
--   keys (fromList ((5,"a") :| [(3,"b")])) == (3 :| [5])
--   </pre>
keys :: NEMap k a -> NonEmpty k

-- | <i>O(n)</i>. An alias for <a>toAscList</a>. Return all key/value pairs
--   in the map in ascending key order.
--   
--   <pre>
--   assocs (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
assocs :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. The non-empty set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList ((5,"a") :| [(3,"b")])) == Data.Set.NonEmpty.fromList (3 :| [5])
--   </pre>
keysSet :: NEMap k a -> NESet k

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
--   
--   <pre>
--   toList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   toAscList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toAscList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in descending order.
--   
--   <pre>
--   toDescList (fromList ((5,"a") :| [(3,"b")])) == ((5,"a") :| [(3,"b")])
--   </pre>
toDescList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
--   
--   Returns a potentially empty map (<a>Map</a>), because we could
--   potentailly filter out all items in the original <a>NEMap</a>.
--   
--   <pre>
--   filter (&gt; "a") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   filter (&gt; "x") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.empty
--   filter (&lt; "a") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.empty
--   </pre>
filter :: (a -> Bool) -> NEMap k a -> Map k a

-- | <i>O(n)</i>. Filter all keys/values that satisfy the predicate.
--   
--   Returns a potentially empty map (<a>Map</a>), because we could
--   potentailly filter out all items in the original <a>NEMap</a>.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
filterWithKey :: (k -> a -> Bool) -> NEMap k a -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Restrict an <a>NEMap</a> to only
--   those keys found in a <a>Set</a>.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>member</a>` s) m
--   m `restrictKeys` s = m `<a>intersection</a>` <a>fromSet</a> (const ()) s
--   </pre>
restrictKeys :: Ord k => NEMap k a -> Set k -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Remove all keys in a <a>Set</a>
--   from an <a>NEMap</a>.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>notMember</a>` s) m
--   m `withoutKeys` s = m `<a>difference</a>` <a>fromSet</a> (const ()) s
--   </pre>
withoutKeys :: Ord k => NEMap k a -> Set k -> Map k a

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two non-empty maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList ((5,"a") :| [(3,"b")])) == These (singleton 3 "b") (singleton 5 "a")
--   partition (&lt; "x") (fromList ((5,"a") :| [(3,"b")])) == This  (fromList ((3, "b") :| [(5, "a")]))
--   partition (&gt; "x") (fromList ((5,"a") :| [(3,"b")])) == That  (fromList ((3, "b") :| [(5, "a")]))
--   </pre>
partition :: (a -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two non-empty maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items, returning the original map.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items, returning the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList ((5,"a") :| [(3,"b")])) == These (singleton 5 "a") (singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList ((5,"a") :| [(3,"b")])) == This  (fromList ((3, "b") :| [(5, "a")]))
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList ((5,"a") :| [(3,"b")])) == That  (fromList ((3, "b") :| [(5, "a")]))
--   </pre>
partitionWithKey :: (k -> a -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(log n)</i>. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   Returns a potentially empty map (<a>Map</a>), because the predicate
--   might fail on the first input.
--   
--   <pre>
--   takeWhileAntitone p = Data.Map.fromDistinctAscList . Data.List.takeWhile (p . fst) . Data.Foldable.toList
--   takeWhileAntitone p = <a>filterWithKey</a> (k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = Data.Map.fromDistinctAscList . Data.List.dropWhile (p . fst) . Data.Foldable.toList
--   dropWhileAntitone p = <a>filterWithKey</a> (k -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Divide a map at the point where a predicate on the
--   keys stops holding. The user is responsible for ensuring that for all
--   keys <tt>j</tt> and <tt>k</tt> in the map, <tt>j &lt; k ==&gt; p j
--   &gt;= p k</tt>.
--   
--   Returns a <a>These</a> with potentially two non-empty maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate never failed for
--   any item, returning the original map.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate failed for the
--   first item, returning the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map up to the
--   point where the predicate on the keys stops holding) and <tt>n2</tt>
--   (the map starting from the point where the predicate stops
--   holding)</li>
--   </ul>
--   
--   <pre>
--   spanAntitone p xs = partitionWithKey (k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point where the predicate switches from holding to not holding (where
--   the predicate is seen to hold before the first key and to fail after
--   the last key).
spanAntitone :: (k -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), because the function
--   could potentially return <a>Nothing</a> on all items in the
--   <a>NEMap</a>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> NEMap k a -> Map k b

-- | <i>O(n)</i>. Map keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), because the function
--   could potentially return <a>Nothing</a> on all items in the
--   <a>NEMap</a>.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (k -> a -> Maybe b) -> NEMap k a -> Map k b

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   Returns a <a>These</a> with potentially two non-empty maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the results were all
--   <a>Left</a>.</li>
--   <li><tt><a>That</a> n2</tt> means that the results were all
--   <a>Right</a>.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map where the
--   results were <a>Left</a>) and <tt>n2</tt> (the map where the results
--   were <a>Right</a>)</li>
--   </ul>
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == These (fromList ((3,"b") :| [(5,"a")])) (fromList ((1,"x") :| [(7,"z")]))
--   
--   mapEither (\ a -&gt; Right a) (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == That (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--   </pre>
mapEither :: (a -> Either b c) -> NEMap k a -> These (NEMap k b) (NEMap k c)

-- | <i>O(n)</i>. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   Returns a <a>These</a> with potentially two non-empty maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the results were all
--   <a>Left</a>.</li>
--   <li><tt><a>That</a> n2</tt> means that the results were all
--   <a>Right</a>.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map where the
--   results were <a>Left</a>) and <tt>n2</tt> (the map where the results
--   were <a>Right</a>)</li>
--   </ul>
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == These (fromList ((1,2) :| [(3,6)])) (fromList ((5,"aa") :| [(7,"zz")]))
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == That (fromList ((1,"x") :| [(3,"b"), (5,"a"), (7,"z")]))
--   </pre>
mapEitherWithKey :: (k -> a -> Either b c) -> NEMap k a -> These (NEMap k b) (NEMap k c)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> k map</tt>) is
--   potentially a <a>These</a> containing up to two <a>NEMap</a>s based on
--   splitting the map into maps containing items before and after the
--   given key <tt>k</tt>. It will never return a map that contains
--   <tt>k</tt> itself.
--   
--   <ul>
--   <li><a>Nothing</a> means that <tt>k</tt> was the only key in the the
--   original map, and so there are no items before or after it.</li>
--   <li><tt><a>Just</a> (<a>This</a> n1)</tt> means <tt>k</tt> was larger
--   than or equal to all items in the map, and <tt>n1</tt> is the entire
--   original map (minus <tt>k</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>That</a> n2)</tt> means <tt>k</tt> was smaller
--   than or equal to all items in the map, and <tt>n2</tt> is the entire
--   original map (minus <tt>k</tt>, if it was present)</li>
--   <li><tt><a>Just</a> (<a>These</a> n1 n2)</tt> gives <tt>n1</tt> (the
--   map of all keys from the original map less than <tt>k</tt>) and
--   <tt>n2</tt> (the map of all keys from the original map greater than
--   <tt>k</tt>)</li>
--   </ul>
--   
--   <pre>
--   split 2 (fromList ((5,"a") :| [(3,"b")])) == Just (That  (fromList ((3,"b") :| [(5,"a")]))  )
--   split 3 (fromList ((5,"a") :| [(3,"b")])) == Just (That  (singleton 5 "a")                  )
--   split 4 (fromList ((5,"a") :| [(3,"b")])) == Just (These (singleton 3 "b") (singleton 5 "a"))
--   split 5 (fromList ((5,"a") :| [(3,"b")])) == Just (This  (singleton 3 "b")                  )
--   split 6 (fromList ((5,"a") :| [(3,"b")])) == Just (This  (fromList ((3,"b") :| [(5,"a")]))  )
--   split 5 (singleton 5 "a")                 == Nothing
--   </pre>
split :: Ord k => k -> NEMap k a -> Maybe (These (NEMap k a) (NEMap k a))

-- | <i>O(log n)</i>. The expression (<tt><a>splitLookup</a> k map</tt>)
--   splits a map just like <a>split</a> but also returns <tt><a>lookup</a>
--   k map</tt>, as a <tt><a>Maybe</a> a</tt>.
--   
--   <pre>
--   splitLookup 2 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (That  (fromList ((3,"b") :| [(5,"a")]))))
--   splitLookup 3 (fromList ((5,"a") :| [(3,"b")])) == (Just "b", Just (That  (singleton 5 "a")))
--   splitLookup 4 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (These (singleton 3 "b") (singleton 5 "a")))
--   splitLookup 5 (fromList ((5,"a") :| [(3,"b")])) == (Just "a", Just (This  (singleton 3 "b"))
--   splitLookup 6 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (This  (fromList ((3,"b") :| [(5,"a")])))
--   splitLookup 5 (singleton 5 "a")                 == (Just "a", Nothing)
--   </pre>
splitLookup :: Ord k => k -> NEMap k a -> (Maybe a, Maybe (These (NEMap k a) (NEMap k a)))

-- | <i>O(1)</i>. Decompose a map into pieces based on the structure of the
--   underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Note that the current implementation does not return more than four
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: NEMap k a -> NonEmpty (NEMap k a)

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. This function is defined as
--   (<tt><a>isSubmapOf</a> = <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression
--   (<tt><a>isSubmapOfBy</a> f t1 t2</tt>) returns <a>True</a> if all keys
--   in <tt>t1</tt> are in tree <tt>t2</tt>, and when <tt>f</tt> returns
--   <a>True</a> when applied to their respective values. For example, the
--   following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (&lt;=) (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (==) (fromList (('a',1) :| [('b',2)])) (fromList (('a',1) :| [('b',2)]))
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (singleton 'a' 2) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (&lt;)  (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (==) (fromList (('a',1) :| [('b',2)])) (singleton 'a' 1)
--   </pre>
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Is this a proper submap? (ie. a
--   submap but not equal). Defined as (<tt><a>isProperSubmapOf</a> =
--   <a>isProperSubmapOfBy</a> (==)</tt>).
isProperSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Is this a proper submap? (ie. a
--   submap but not equal). The expression (<tt><a>isProperSubmapOfBy</a> f
--   m1 m2</tt>) returns <a>True</a> when <tt>m1</tt> and <tt>m2</tt> are
--   not equal, all keys in <tt>m1</tt> are in <tt>m2</tt>, and when
--   <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (singleton 1 1) (fromList ((1,1) :| [(2,2)]))
--   isProperSubmapOfBy (&lt;=) (singleton 1 1) (fromList ((1,1) :| [(2,2)]))
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList ((1,1) :| [(2,2)])) (fromList ((1,1) :| [(2,2)]))
--   isProperSubmapOfBy (==) (fromList ((1,1) :| [(2,2)])) (singleton 1 1))
--   isProperSubmapOfBy (&lt;)  (singleton 1 1)               (fromList ((1,1) :| [(2,2)]))
--   </pre>
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool

-- | <i>O(log n)</i>. Lookup the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   
--   <pre>
--   isJust (lookupIndex 2 (fromList ((5,"a") :| [(3,"b")])))   == False
--   fromJust (lookupIndex 3 (fromList ((5,"a") :| [(3,"b")]))) == 0
--   fromJust (lookupIndex 5 (fromList ((5,"a") :| [(3,"b")]))) == 1
--   isJust (lookupIndex 6 (fromList ((5,"a") :| [(3,"b")])))   == False
--   </pre>
lookupIndex :: Ord k => k -> NEMap k a -> Maybe Int

-- | <i>O(log n)</i>. Return the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   Calls <a>error</a> when the key is not a <a>member</a> of the map.
--   
--   <pre>
--   findIndex 2 (fromList ((5,"a") :| [(3,"b")]))    Error: element is not in the map
--   findIndex 3 (fromList ((5,"a") :| [(3,"b")])) == 0
--   findIndex 5 (fromList ((5,"a") :| [(3,"b")])) == 1
--   findIndex 6 (fromList ((5,"a") :| [(3,"b")]))    Error: element is not in the map
--   </pre>
findIndex :: Ord k => k -> NEMap k a -> Int

-- | <i>O(log n)</i>. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList ((5,"a") :| [(3,"b")])) == (3,"b")
--   elemAt 1 (fromList ((5,"a") :| [(3,"b")])) == (5, "a")
--   elemAt 2 (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   </pre>
elemAt :: Int -> NEMap k a -> (k, a)

-- | <i>O(log n)</i>. Update the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   Returns a possibly empty map (<a>Map</a>), because the function might
--   end up deleting the last key in the map. See <a>adjustAt</a> for a
--   version that disallows deletion, guaranteeing that the result is also
--   a non-empty Map.
--   
--   <pre>
--   updateAt (\ _ _ -&gt; Just "x") 0    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "x"), (5, "a")]
--   updateAt (\ _ _ -&gt; Just "x") 1    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "x")]
--   updateAt (\ _ _ -&gt; Just "x") 2    (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\ _ _ -&gt; Just "x") (-1) (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  0    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   updateAt (\_ _  -&gt; Nothing)  1    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   updateAt (\_ _  -&gt; Nothing)  2    (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  (-1) (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   </pre>
updateAt :: (k -> a -> Maybe a) -> Int -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Variant of <a>updateAt</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
adjustAt :: (k -> a -> a) -> Int -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   Returns a potentially empty map (<a>Map</a>) because of the
--   possibility of deleting the last item in a map.
--   
--   <pre>
--   deleteAt 0  (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   deleteAt 1  (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   deleteAt 2 (fromList ((5,"a") :| [(3,"b")]))     Error: index out of range
--   deleteAt (-1) (fromList ((5,"a") :| [(3,"b")]))  Error: index out of range
--   </pre>
deleteAt :: Int -> NEMap k a -> Map k a

-- | Take a given number of entries in key order, beginning with the
--   smallest keys.
--   
--   Returns a possibly empty map (<a>Map</a>), which can only happen if we
--   call <tt>take 0</tt>.
--   
--   <pre>
--   take n = Data.Map.fromDistinctAscList . Data.List.NonEmpty.take n . <a>toList</a>
--   </pre>
take :: Int -> NEMap k a -> Map k a

-- | Drop a given number of entries in key order, beginning with the
--   smallest keys.
--   
--   Returns a possibly empty map (<a>Map</a>), in case we drop all of the
--   elements (which can happen if we drop a number greater than or equal
--   to the number of items in the map)
--   
--   <pre>
--   drop n = Data.Map.fromDistinctAscList . Data.List.NonEmpty.drop' n . <a>toList</a>
--   </pre>
drop :: Int -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Split a map at a particular index <tt>i</tt>.
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that there are less than <tt>i</tt>
--   items in the map, and <tt>n1</tt> is the original map.</li>
--   <li><tt><a>That</a> n2</tt> means <tt>i</tt> was 0; we dropped 0
--   items, so <tt>n2</tt> is the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (taking <tt>i</tt>
--   items from the original map) and <tt>n2</tt> (dropping <tt>i</tt>
--   items from the original map))</li>
--   </ul>
splitAt :: Int -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(1)</i>. The minimal key of the map. Note that this is total,
--   making <a>lookupMin</a> obsolete. It is constant-time, so has better
--   asymptotics than <tt>Data.Map.lookupMin</tt> and
--   <tt>Data.Map.findMin</tt>, as well.
--   
--   <pre>
--   findMin (fromList ((5,"a") :| [(3,"b")])) == (3,"b")
--   </pre>
findMin :: NEMap k a -> (k, a)

-- | <i>O(log n)</i>. The maximal key of the map. Note that this is total,
--   making <a>lookupMin</a> obsolete.
--   
--   <pre>
--   findMax (fromList ((5,"a") :| [(3,"b")])) == (5,"a")
--   </pre>
findMax :: NEMap k a -> (k, a)

-- | <i>O(1)</i>. Delete the minimal key. Returns a potentially empty map
--   (<a>Map</a>), because we might end up deleting the final key in a
--   singleton map. It is constant-time, so has better asymptotics than
--   <a>deleteMin</a>.
--   
--   <pre>
--   deleteMin (fromList ((5,"a") :| [(3,"b"), (7,"c")])) == Data.Map.fromList [(5,"a"), (7,"c")]
--   deleteMin (singleton 5 "a") == Data.Map.empty
--   </pre>
deleteMin :: NEMap k a -> Map k a

-- | <i>O(log n)</i>. Delete the maximal key. Returns a potentially empty
--   map (<a>Map</a>), because we might end up deleting the final key in a
--   singleton map.
--   
--   <pre>
--   deleteMax (fromList ((5,"a") :| [(3,"b"), (7,"c")])) == Data.Map.fromList [(3,"b"), (5,"a")]
--   deleteMax (singleton 5 "a") == Data.Map.empty
--   </pre>
deleteMax :: NEMap k a -> Map k a

-- | <i>O(1)</i>. Delete and find the minimal key-value pair. It is
--   constant-time, so has better asymptotics that
--   <tt>Data.Map.minView</tt> for <a>Map</a>.
--   
--   Note that unlike <tt>Data.Map.deleteFindMin</tt> for <a>Map</a>, this
--   cannot ever fail, and so is a total function. However, the result
--   <a>Map</a> is potentially empty, since the original map might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMin (fromList ((5,"a") :| [(3,"b"), (10,"c")])) == ((3,"b"), Data.Map.fromList [(5,"a"), (10,"c")])
--   </pre>
deleteFindMin :: NEMap k a -> ((k, a), Map k a)

-- | <i>O(log n)</i>. Delete and find the minimal key-value pair.
--   
--   Note that unlike <tt>Data.Map.deleteFindMax</tt> for <a>Map</a>, this
--   cannot ever fail, and so is a total function. However, the result
--   <a>Map</a> is potentially empty, since the original map might have
--   contained just a single item.
--   
--   <pre>
--   deleteFindMax (fromList ((5,"a") :| [(3,"b"), (10,"c")])) == ((10,"c"), Data.Map.fromList [(3,"b"), (5,"a")])
--   </pre>
deleteFindMax :: NEMap k a -> ((k, a), Map k a)

-- | <i>O(1)</i> if delete, <i>O(log n)</i> otherwise. Update the value at
--   the minimal key. Returns a potentially empty map (<a>Map</a>), because
--   we might end up deleting the final key in the map if the function
--   returns <a>Nothing</a>. See <a>adjustMin</a> for a version that can
--   guaruntee that we return a non-empty map.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update the value at the maximal key. Returns a
--   potentially empty map (<a>Map</a>), because we might end up deleting
--   the final key in the map if the function returns <a>Nothing</a>. See
--   <a>adjustMax</a> for a version that can guarantee that we return a
--   non-empty map.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(1)</i>. A version of <a>updateMin</a> that disallows deletion,
--   allowing us to guarantee that the result is also non-empty.
adjustMin :: (a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. A version of <a>updateMax</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
adjustMax :: (a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(1)</i> if delete, <i>O(log n)</i> otherwise. Update the value at
--   the minimal key. Returns a potentially empty map (<a>Map</a>), because
--   we might end up deleting the final key in the map if the function
--   returns <a>Nothing</a>. See <a>adjustMinWithKey</a> for a version that
--   guaruntees a non-empty map.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMinWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update the value at the maximal key. Returns a
--   potentially empty map (<a>Map</a>), because we might end up deleting
--   the final key in the map if the function returns <a>Nothing</a>. See
--   <a>adjustMaxWithKey</a> for a version that guaruntees a non-empty map.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMaxWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(1)</i>. A version of <a>adjustMaxWithKey</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
--   Note that it also is able to have better asymptotics than
--   <a>updateMinWithKey</a> in general.
adjustMinWithKey :: (k -> a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. A version of <a>updateMaxWithKey</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
adjustMaxWithKey :: (k -> a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(1)</i>. Retrieves the value associated with minimal key of the
--   map, and the map stripped of that element. It is constant-time, so has
--   better asymptotics than <tt>Data.Map.minView</tt> for <a>Map</a>.
--   
--   Note that unlike <tt>Data.Map.minView</tt> for <a>Map</a>, this cannot
--   ever fail, so doesn't need to return in a <a>Maybe</a>. However, the
--   result <a>Map</a> is potentially empty, since the original map might
--   have contained just a single item.
--   
--   <pre>
--   minView (fromList ((5,"a") :| [(3,"b")])) == ("b", Data.Map.singleton 5 "a")
--   </pre>
minView :: NEMap k a -> (a, Map k a)

-- | <i>O(log n)</i>. Retrieves the value associated with maximal key of
--   the map, and the map stripped of that element.
--   
--   Note that unlike <tt>Data.Map.maxView</tt> from <a>Map</a>, this
--   cannot ever fail, so doesn't need to return in a <a>Maybe</a>.
--   However, the result <a>Map</a> is potentially empty, since the
--   original map might have contained just a single item.
--   
--   <pre>
--   maxView (fromList ((5,"a") :| [(3,"b")])) == ("a", Data.Map.singleton 3 "b")
--   </pre>
maxView :: NEMap k a -> (a, Map k a)

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
