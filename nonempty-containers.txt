-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-empty variants of containers data types, with full API
--   
--   Efficient and optimized non-empty versions of types from
--   <i>containers</i>. Inspired by <i>non-empty-containers</i> library,
--   except attempting a more faithful port (with under-the-hood
--   optimizations) of the full <i>containers</i> API.
@package nonempty-containers
@version 0.1.0.0

module Data.Map.NonEmpty.Internal
data NEMap k a
NEMap :: !k -> a -> !Map k a -> NEMap k a

-- | invariant: must be smaller than smallest key in map
[nemK0] :: NEMap k a -> !k
[nemV0] :: NEMap k a -> a
[nemMap] :: NEMap k a -> !Map k a
toMap :: NEMap k a -> Map k a
foldr :: (a -> b -> b) -> b -> NEMap k a -> b
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b
foldr1 :: (a -> a -> a) -> NEMap k a -> a
foldr1' :: (a -> a -> a) -> NEMap k a -> a
foldl :: (a -> b -> a) -> a -> NEMap k b -> a
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a
foldl1 :: (a -> a -> a) -> NEMap k a -> a
foldl1' :: (a -> a -> a) -> NEMap k a -> a
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a
elems :: NEMap k a -> NonEmpty a
size :: NEMap k a -> Int
traverseWithKey :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)
insertMinMap :: k -> a -> Map k a -> Map k a
insertMaxMap :: k -> a -> Map k a -> Map k a
instance GHC.Base.Functor (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Data.Map.NonEmpty.Internal.NEMap k a)
instance Data.Foldable.Foldable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Traversable.Traversable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Map.NonEmpty.Internal.NEMap k)

module Data.Map.NonEmpty
data NEMap k a
nonEmptyMap :: Map k a -> Maybe (NEMap k a)
toMap :: NEMap k a -> Map k a
insertMap :: Ord k => k -> a -> Map k a -> NEMap k a
insertMapWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> NEMap k a
insertMapWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> NEMap k a
insertMapMin :: k -> a -> Map k a -> NEMap k a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a
singleton :: k -> a -> NEMap k a
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a
fromListWith :: Ord k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromAscList :: Eq k => NonEmpty (k, a) -> NEMap k a
fromAscListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromDistinctAscList :: NonEmpty (k, a) -> NEMap k a
insert :: Ord k => k -> a -> NEMap k a -> NEMap k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> (Maybe a, NEMap k a)
delete :: Ord k => k -> NEMap k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> NEMap k a -> NEMap k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> NEMap k a -> NEMap k a
update :: Ord k => (a -> Maybe a) -> k -> NEMap k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> NEMap k a -> Map k a
alterF :: (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> NEMap k a -> f (Map k a)
lookup :: Ord k => k -> NEMap k a -> Maybe a
(!?) :: Ord k => NEMap k a -> k -> Maybe a
(!) :: Ord k => NEMap k a -> k -> a
findWithDefault :: Ord k => a -> k -> NEMap k a -> a
member :: Ord k => k -> NEMap k a -> Bool
notMember :: Ord k => k -> NEMap k a -> Bool
lookupLT :: Ord k => k -> NEMap k a -> Maybe (k, a)
lookupGT :: Ord k => k -> NEMap k a -> Maybe (k, a)
lookupLE :: Ord k => k -> NEMap k a -> Maybe (k, a)
lookupGE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool
size :: NEMap k a -> Int
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a
unionWith :: Ord k => (a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a
unionsWith :: (Foldable1 f, Ord k) => (a -> a -> a) -> f (NEMap k a) -> NEMap k a
map :: (a -> b) -> NEMap k a -> NEMap k b
mapWithKey :: (k -> a -> b) -> NEMap k a -> NEMap k b
traverseWithKey :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)
traverseMaybeWithKey :: Apply t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapKeys :: Ord k2 => (k1 -> k2) -> NEMap k1 a -> NEMap k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> NEMap k1 a -> NEMap k2 a
mapKeysMonotonic :: (k1 -> k2) -> NEMap k1 a -> NEMap k2 a
foldr :: (a -> b -> b) -> b -> NEMap k a -> b
foldl :: (a -> b -> a) -> a -> NEMap k b -> a
foldrWithKey :: (k -> a -> b -> b) -> b -> NEMap k a -> b
foldlWithKey :: (a -> k -> b -> a) -> a -> NEMap k b -> a
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b
foldr1' :: (a -> a -> a) -> NEMap k a -> a
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a
foldl1 :: (a -> a -> a) -> NEMap k a -> a
foldl1' :: (a -> a -> a) -> NEMap k a -> a
foldrWithKey' :: (k -> a -> b -> b) -> b -> NEMap k a -> b
foldlWithKey' :: (a -> k -> b -> a) -> a -> NEMap k b -> a
elems :: NEMap k a -> NonEmpty a
keys :: NEMap k a -> NonEmpty k
assocs :: NEMap k a -> NonEmpty (k, a)
toNonEmpty :: NEMap k a -> NonEmpty (k, a)
toAscList :: NEMap k a -> NonEmpty (k, a)
toDescList :: NEMap k a -> NonEmpty (k, a)
filter :: (a -> Bool) -> NEMap k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> NEMap k a -> Map k a
restrictKeys :: Ord k => NEMap k a -> Set k -> Map k a
withoutKeys :: Ord k => NEMap k a -> Set k -> Map k a
partition :: (a -> Bool) -> NEMap k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> NEMap k a -> (Map k a, Map k a)
takeWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a
spanAntitone :: (k -> Bool) -> NEMap k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> NEMap k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> NEMap k a -> Map k b
mapEither :: (a -> Either b c) -> NEMap k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> NEMap k a -> (Map k b, Map k c)
split :: Ord k => k -> NEMap k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> NEMap k a -> (Map k a, Maybe a, Map k a)
isSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool
findMin :: NEMap k a -> (k, a)
findMax :: NEMap k a -> (k, a)
deleteMin :: NEMap k a -> Map k a
deleteMax :: NEMap k a -> Map k a
deleteFindMin :: NEMap k a -> ((k, a), Map k a)
deleteFindMax :: NEMap k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> NEMap k a -> Map k a
updateMax :: (a -> Maybe a) -> NEMap k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a
minView :: NEMap k a -> (a, Map k a)
maxView :: NEMap k a -> (a, Map k a)
valid :: Ord k => NEMap k a -> Bool
