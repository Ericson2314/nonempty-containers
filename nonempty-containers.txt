-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-empty variants of containers data types, with full API
--   
--   Efficient and optimized non-empty versions of types from
--   <i>containers</i>. Inspired by <i>non-empty-containers</i> library,
--   except attempting a more faithful port (with under-the-hood
--   optimizations) of the full <i>containers</i> API.
@package nonempty-containers
@version 0.1.0.0


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   This contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
module Data.Map.NonEmpty.Internal

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNEMap</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a (possibly empty) <a>Map</a>
--   with <a>toMap</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEMap k a
NEMap :: !k -> a -> !Map k a -> NEMap k a

-- | invariant: must be smaller than smallest key in map
[nemK0] :: NEMap k a -> !k
[nemV0] :: NEMap k a -> a
[nemMap] :: NEMap k a -> !Map k a

-- | <i>O(1)</i>. A map with a single element.
--   
--   <pre>
--   singleton 1 'a'        == fromList ((1, 'a') :| [])
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: k -> a -> NEMap k a

-- | <i>O(log n)</i> Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Map</a> being an <a>NEMap</a>.
--   
--   <pre>
--   nonEmptyMap (Data.Map.fromList [(3,"a"), (5,"b")]) == fromList ((3,"a") :| [(5,"b")])
--   </pre>
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <a>fromAscList</a>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
--   
--   <pre>
--   fromList ((5,"a") :| [(3,"b"), (5, "c")]) == fromList ((5,"c") :| [(3,"b")])
--   fromList ((5,"c") :| [(3,"b"), (5, "a")]) == fromList ((5,"a") :| [(3,"b")])
--   </pre>
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
--   
--   <pre>
--   toList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "bx") :| [(5, "ax")])
--   </pre>
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   See <a>insertMapWith</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "xxxa")])
--   insertWith (++) 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "a"), (7, "C")])
--   </pre>
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a non-empty list of maps.
--   
--   <pre>
--   unions (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions (fromList ((5, "A3") :| [(3, "B3")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "a") :| [(3, "b")])])
--       == fromList ((3, "B3") :| [(5, "A3"), (7, "C")])
--   </pre>
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
--   
--   <pre>
--   elems (fromList ((5,"a") :| [(3,"b")])) == ("b" :| ["a"])
--   </pre>
elems :: NEMap k a -> NonEmpty a

-- | <i>O(1)</i>. The number of elements in the map.
--   
--   <pre>
--   size (singleton 1 'a')                          == 1
--   size (fromList ((1,'a') :| [(2,'c'), (3,'b')])) == 3
--   </pre>
size :: NEMap k a -> Int

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the map in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toMap (fromList ((3,"a") :| [(5,"b")])) == Data.Map.fromList [(3,"a"), (5,"b")]
--   </pre>
toMap :: NEMap k a -> Map k a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A version of <a>foldr</a> that uses the value at the
--   maximal key in the map as the starting value.
--   
--   Note that, unlike <a>foldr1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldr1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly greater than</i> the new key. That is, the new key must be
--   <i>strictly less than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <a>insert</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
insertMinMap :: k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly less than</i> the new key. That is, the new key must be
--   <i>strictly greater than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <a>insert</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
insertMaxMap :: k -> a -> Map k a -> Map k a

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.NonEmpty.Internal.NEMap k a)
instance Data.Functor.Classes.Eq2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Eq k => Data.Functor.Classes.Eq1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Ord2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Show2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k) => Data.Functor.Classes.Read1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read e) => GHC.Read.Read (Data.Map.NonEmpty.Internal.NEMap k e)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.NonEmpty.Internal.NEMap k a)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Base.Functor (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Foldable.Foldable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Traversable.Traversable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Map.NonEmpty.Internal.NEMap k)


-- | <h1>Non-Empty Finite Maps (lazy interface)</h1>
--   
--   The <tt><a>NEMap</a> k v</tt> type represents a non-empty finite map
--   (sometimes called a dictionary) from keys of type <tt>k</tt> to values
--   of type <tt>v</tt>. An <a>NEMap</a> is strict in its keys but lazy in
--   its values.
--   
--   See documentation for <a>NEMap</a> for information on how to convert
--   and manipulate such non-empty maps.
--   
--   This module essentially re-imports the API of <a>Data.Map.Lazy</a> and
--   its <a>Map</a> type, along with semantics and asymptotics. In most
--   situations, asymptotics are different only by a constant factor. In
--   some situations, asmyptotics are even better (constant-time instead of
--   log-time). All typeclass constraints are identical to their
--   <a>Data.Map</a> counterparts.
--   
--   Because <a>NEMap</a> is implemented using <a>Map</a>, all of the
--   caveats of using <a>Map</a> apply (such as the limitation of the
--   maximum size of maps).
--   
--   All functions take non-empty maps as inputs. In situations where their
--   results can be guarunteed to also be non-empty, they also return
--   non-empty maps. In situations where their results could potentially be
--   empty, <a>Map</a> is returned instead.
--   
--   Some variants of functions (like <a>alter'</a>, <a>alterF'</a>,
--   <a>adjustAt</a>, <a>adjustMin</a>, <a>adjustMax</a>,
--   <a>adjustMinWithKey</a>, <a>adjustMaxWithKey</a>) are provided in a
--   way restructured to preserve guaruntees of non-empty maps being
--   returned.
--   
--   Some functions (like <a>mapEither</a>, <a>partition</a>, <a>span</a>,
--   <a>spanAntitone</a>, <a>split</a>) have modified return types to
--   account for possible configurations of non-emptiness.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with <a>Prelude</a> and <a>Data.Map</a> functions:
--   
--   <pre>
--   import qualified Data.Map.NonEmpty as NEM
--   </pre>
module Data.Map.NonEmpty

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNEMap</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a (possibly empty) <a>Map</a>
--   with <a>toMap</a> or <a>IsNonEmpty</a>, essentially "obscuring" the
--   non-empty property from the type.
data NEMap k a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | <i>O(1)</i> match, <i>O(log n)</i> usage of contents. The
--   <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow you to treat a
--   <a>Map</a> as if it were either a <tt><a>IsNonEmpty</a> n</tt> (where
--   <tt>n</tt> is a <a>NEMap</a>) or an <a>IsEmpty</a>.
--   
--   For example, you can pattern match on a <a>Map</a>:
--   
--   <pre>
--   myFunc :: <a>Map</a> K X -&gt; Y
--   myFunc m = case m of
--       <a>IsNonEmpty</a> n -&gt; -- here, n is a <a>IsNonEmpty</a>, m is proven not empty.
--       <a>IsEmpty</a>      -&gt; -- here, m is empty.
--   </pre>
--   
--   Matching on <tt><a>IsNonEmpty</a> n</tt> means that the original
--   <a>Map</a> was <i>not</i> empty, and you have a verified-non-empty
--   <a>NEMap</a> <tt>n</tt> to use.
--   
--   Note that patching on this pattern is <i>O(1)</i>. However, using the
--   contents requires a <i>O(log n)</i> cost that is deferred until after
--   the pattern is matched on (and is not incurred at all if the contents
--   are never used).
--   
--   This is a bidirectional pattern, so you can use <a>IsNonEmpty</a> to
--   convert a <a>NEMap</a> back into a <a>Map</a>, obscuring its
--   non-emptiness (see <a>toMap</a>).
pattern IsNonEmpty :: NEMap k a -> Map k a

-- | <i>O(1)</i>. The <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns allow
--   you to treat a <a>Map</a> as if it were either a <tt><a>IsNonEmpty</a>
--   n</tt> (where <tt>n</tt> is a <a>NEMap</a>) or an <a>IsEmpty</a>.
--   
--   Matching on <a>IsEmpty</a> means that the original <a>Map</a> was
--   empty.
--   
--   See <a>IsNonEmpty</a> for more information.
pattern IsEmpty :: Map k a

-- | <i>O(log n)</i> Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   See <a>IsNonEmpty</a> for a pattern synonym that lets you "match on"
--   the possiblity of a <a>Map</a> being an <a>NEMap</a>.
--   
--   <pre>
--   nonEmptyMap (Data.Map.fromList [(3,"a"), (5,"b")]) == fromList ((3,"a") :| [(5,"b")])
--   </pre>
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
--   
--   Can be thought of as "obscuring" the non-emptiness of the map in its
--   type. See the <a>IsNotEmpty</a> pattern.
--   
--   <a>nonEmptyMap</a> and <tt><a>maybe</a> <a>empty</a> <a>toMap</a></tt>
--   form an isomorphism: they are perfect structure-preserving inverses of
--   eachother.
--   
--   <pre>
--   toMap (fromList ((3,"a") :| [(5,"b")])) == Data.Map.fromList [(3,"a"), (5,"b")]
--   </pre>
toMap :: NEMap k a -> Map k a

-- | <i>O(log n)</i>. A general continuation-based way to consume a
--   <a>Map</a> as if it were an <a>NEMap</a>. <tt><a>withNEMap</a> def
--   f</tt> will take a <a>Map</a>. If map is empty, it will evaluate to
--   <tt>def</tt>. Otherwise, a non-empty map <a>NEMap</a> will be fed to
--   the function <tt>f</tt> instead.
--   
--   <pre>
--   <a>nonEmptyMap</a> == <a>withNEMap</a> <a>Nothing</a> <a>Just</a>
--   </pre>
withNEMap :: r -> (NEMap k a -> r) -> Map k a -> r

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. If key is already
--   present, will overwrite the original value.
--   
--   See <a>insertMapMin</a> for a version that is constant-time if the new
--   key is <i>strictly smaller than</i> all keys in the original map.
--   
--   <pre>
--   insertMap 4 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(4,"c"), (5,"a")])
--   insertMap 4 "c" Data.Map.empty == singleton 4 "c"
--   </pre>
insertMap :: Ord k => k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. Uses a combining
--   function with the new value as the first argument if the key is
--   already present.
--   
--   <pre>
--   insertMapWith (++) 4 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(4,"c"), (5,"a")])
--   insertMapWith (++) 5 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(5,"ca")])
--   </pre>
insertMapWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Because of this, we know that the map must have at
--   least one element, and so therefore cannot be empty. Uses a combining
--   function with the key and new value as the first and second arguments
--   if the key is already present.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3, "b") :| [(5, "5:xxx|a")])
--   insertWithKey f 7 "xxx" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   insertWithKey f 5 "xxx" Data.Map.empty                         == singleton 5 "xxx"
--   </pre>
insertMapWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(1)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly less than</i> all keys in
--   the input map. The keys in the original map must all be <i>strictly
--   greater than</i> the new key. <i>The precondition is not checked.</i>
--   
--   <pre>
--   insertMap 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((2,"c") :| [(3,"b"), (5,"a")])
--   valid (insertMap 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == True
--   valid (insertMap 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   valid (insertMap 3 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   </pre>
insertMapMin :: k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly greater than</i> all keys
--   in the input map. The keys in the original map must all be <i>strictly
--   less than</i> the new key. <i>The precondition is not checked.</i>
--   
--   While this has the same asymptotics as <a>insertMap</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
--   
--   <pre>
--   insertMap 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")]) == fromList ((3,"b") :| [(5,"a"), (7,"c")])
--   valid (insertMap 7 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == True
--   valid (insertMap 2 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   valid (insertMap 5 "c" (Data.Map.fromList [(5,"a"), (3,"b")])) == False
--   </pre>
insertMapMax :: k -> a -> Map k a -> NEMap k a

-- | <i>O(1)</i>. A map with a single element.
--   
--   <pre>
--   singleton 1 'a'        == fromList ((1, 'a') :| [])
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: k -> a -> NEMap k a

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <a>fromAscList</a>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
--   
--   <pre>
--   fromList ((5,"a") :| [(3,"b"), (5, "c")]) == fromList ((5,"c") :| [(3,"b")])
--   fromList ((5,"c") :| [(3,"b"), (5, "a")]) == fromList ((5,"a") :| [(3,"b")])
--   </pre>
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n*log n)</i>. Build a map from a non-empty list of key/value
--   pairs with a combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) ((5,"a") :| [(5,"b"), (3,"b"), (3,"a"), (5,"a")]) == fromList ((3, "ab") :| [(5, "aba")])
--   </pre>
fromListWith :: Ord k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n*log n)</i>. Build a map from a non-empty list of key/value
--   pairs with a combining function. See also <a>fromAscListWithKey</a>.
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ a1 ++ a2
--   fromListWithKey f ((5,"a") :| [(5,"b"), (3,"b"), (3,"a"), (5,"a")]) == fromList ((3, "3ab") :| [(5, "5a5ba")])
--   </pre>
fromListWithKey :: Ord k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time. <i>The precondition (input list is ascending) is not
--   checked.</i>
--   
--   <pre>
--   fromAscList ((3,"b") :| [(5,"a")])          == fromList ((3, "b") :| [(5, "a")])
--   fromAscList ((3,"b") :| [(5,"a"), (5,"b")]) == fromList ((3, "b") :| [(5, "b")])
--   valid (fromAscList ((3,"b") :| [(5,"a"), (5,"b")])) == True
--   valid (fromAscList ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromAscList :: Eq k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is ascending) is not checked./
--   
--   <pre>
--   fromAscListWith (++) ((3,"b") :| [(5,"a"), (5,"b")]) == fromList ((3, "b") :| [(5, "ba")])
--   valid (fromAscListWith (++) ((3,"b") :| [(5,"a"), (5,"b"))]) == True
--   valid (fromAscListWith (++) ((5,"a") :| [(3,"b"), (5,"b"))]) == False
--   </pre>
fromAscListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is ascending) is not checked./
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromAscListWithKey f ((3,"b") :| [(5,"a"), (5,"b"), (5,"b")]) == fromList ((3, "b") :| [(5, "5:b5:ba")])
--   valid (fromAscListWithKey f ((3,"b") :| [(5,"a"), (5,"b"), (5,"b")])) == True
--   valid (fromAscListWithKey f ((5,"a") :| [(3,"b"), (5,"b"), (5,"b")])) == False
--   </pre>
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from an ascending non-empty list of distinct
--   elements in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList ((3,"b") :| [(5,"a")]) == fromList ((3, "b") :| [(5, "a")])
--   valid (fromDistinctAscList ((3,"b") :| [(5,"a")]))          == True
--   valid (fromDistinctAscList ((3,"b") :| [(5,"a"), (5,"b")])) == False
--   </pre>
fromDistinctAscList :: NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time. <i>The precondition (input list is descending) is not
--   checked.</i>
--   
--   <pre>
--   fromDescList ((5,"a") :| [(3,"b")])          == fromList ((3, "b") :| [(5, "a")])
--   fromDescList ((5,"a") :| [(5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "b")])
--   valid (fromDescList ((5,"a") :| [(5,"b"), (3,"b")])) == True
--   valid (fromDescList ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromDescList :: Eq k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is descending) is not checked./
--   
--   <pre>
--   fromDescListWith (++) ((5,"a") :| [(5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "ba")])
--   valid (fromDescListWith (++) ((5,"a") :| [(5,"b"), (3,"b")])) == True
--   valid (fromDescListWith (++) ((5,"a") :| [(3,"b"), (5,"b")])) == False
--   </pre>
fromDescListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending non-empty list in linear
--   time with a combining function for equal keys. /The precondition
--   (input list is descending) is not checked./
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromDescListWithKey f ((5,"a") :| [(5,"b"), (5,"b"), (3,"b")]) == fromList ((3, "b") :| [(5, "5:b5:ba")])
--   valid (fromDescListWithKey f ((5,"a") :| [(5,"b"), (5,"b"), (3,"b")])) == True
--   valid (fromDescListWithKey f ((5,"a") :| [(3,"b"), (5,"b"), (5,"b")])) == False
--   </pre>
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Build a map from a descending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctDescList ((5,"a") :| [(3,"b")]) == fromList ((3, "b") :| [(5, "a")])
--   valid (fromDistinctDescList ((5,"a") :| [(3,"b")]))          == True
--   valid (fromDistinctDescList ((5,"a") :| [(5,"b"), (3,"b")])) == False
--   </pre>
fromDistinctDescList :: NonEmpty (k, a) -> NEMap k a

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   See <a>insertMap</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insert 5 'x' (fromList ((5,'a') :| [(3,'b')])) == fromList ((3, 'b') :| [(5, 'x')])
--   insert 7 'x' (fromList ((5,'a') :| [(3,'b')])) == fromList ((3, 'b') :| [(5, 'a'), (7, 'x')])
--   </pre>
insert :: Ord k => k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   See <a>insertMapWith</a> for a version where the first argument is a
--   <a>Map</a>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "xxxa")])
--   insertWith (++) 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Insert with a function, combining key, new value and
--   old value. <tt><a>insertWithKey</a> f key value mp</tt> will insert
--   the pair (key, value) into <tt>mp</tt> if key does not exist in the
--   map. If the key does exist, the function will insert the pair
--   <tt>(key,f key new_value old_value)</tt>. Note that the key passed to
--   f is the same key passed to <a>insertWithKey</a>.
--   
--   See <a>insertMapWithKey</a> for a version where the first argument is
--   a <a>Map</a>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "5:xxx|a")])
--   insertWithKey f 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a"), (7, "xxx")])
--   </pre>
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Combines insert operation with old value retrieval.
--   The expression (<tt><a>insertLookupWithKey</a> f k x map</tt>) is a
--   pair where the first element is equal to (<tt><a>lookup</a> k
--   map</tt>) and the second element equal to (<tt><a>insertWithKey</a> f
--   k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList ((5,"a") :| [(3,"b")])) == (Just "a", fromList ((3, "b") :| [(5, "5:xxx|a")]))
--   insertLookupWithKey f 7 "xxx" (fromList ((5,"a") :| [(3,"b")])) == (Nothing,  fromList ((3, "b") :| [(5, "a"), (7, "xxx")]))
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList ((5,"a") :| [(3,"b")])) == (Just "a", fromList ((3, "b") :| [(5, "x")]))
--   insertLookup 7 "x" (fromList ((5,"a") :| [(3,"b")])) == (Nothing,  fromList ((3, "b") :| [(5, "a"), (7, "x")]))
--   </pre>
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> (Maybe a, NEMap k a)

-- | <i>O(log n)</i>. Delete a key and its value from the non-empty map. A
--   potentially empty map (<a>Map</a>) is returned, since this might
--   delete the last item in the <a>NEMap</a>. When the key is not a member
--   of the map, is equivalent to <a>toMap</a>.
--   
--   <pre>
--   delete 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   delete 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.Singleton [(3, "b"), (5, "a")]
--   </pre>
delete :: Ord k => k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update a value at a specific key with the result of
--   the provided function. When the key is not a member of the map, the
--   original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "new a")])
--   adjust ("new " ++) 7 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a")])
--   </pre>
adjust :: Ord k => (a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "5:new a")])
--   adjustWithKey f 7 (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "b") :| [(5, "a")])
--   </pre>
adjustWithKey :: Ord k => (k -> a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. The expression (<tt><a>update</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
update :: Ord k => (a -> Maybe a) -> k -> NEMap k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k
--   map</tt>) updates the value <tt>x</tt> at <tt>k</tt> (if it is in the
--   map). If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted.
--   If it is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the
--   new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> (Maybe a, Map k a)

-- | <i>O(log n)</i>. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <a>Map</a>. In
--   short : <tt>Data.Map.lookup k (<a>alter</a> f k m) = f (<a>lookup</a>
--   k m)</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), because we can't know
--   ahead of time if the function returns <a>Nothing</a> and deletes the
--   final item in the <a>NEMap</a>.
--   
--   See <a>alterF'</a> for a version that disallows deletion, and so
--   therefore can return <a>NEMap</a>.
--   
--   <pre>
--   let f _ = Nothing
--   alter f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a")]
--   alter f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   
--   let f _ = Just "c"
--   alter f 7 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "a"), (7, "c")]
--   alter f 5 (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "c")]
--   </pre>
alter :: Ord k => (Maybe a -> Maybe a) -> k -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>alterF</a> f k map</tt>)
--   alters the value <tt>x</tt> at <tt>k</tt>, or absence thereof.
--   <a>alterF</a> can be used to inspect, insert, delete, or update a
--   value in a <a>Map</a>. In short: <tt>Data.Map.lookup k &lt;$&gt;
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; NEMap Int String -&gt; IO (Map Int String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   Like <tt>Data.Map.alterF</tt> for <a>Map</a>, <a>alterF</a> can be
--   considered to be a unifying generalization of <a>lookup</a> and
--   <a>delete</a>; however, as a constrast, it cannot be used to implement
--   <a>insert</a>, because it must return a <a>Map</a> instead of an
--   <a>NEMap</a> (because the function might delete the final item in the
--   <a>NEMap</a>). When used with trivial functors like <a>Identity</a>
--   and <a>Const</a>, it is often slightly slower than specialized
--   <a>lookup</a> and <a>delete</a>. However, when the functor is
--   non-trivial and key comparison is not particularly cheap, it is the
--   fastest way.
--   
--   See <a>alterF'</a> for a version that disallows deletion, and so
--   therefore can return <a>NEMap</a> and be used to implement
--   <a>insert</a>
--   
--   Note on rewrite rules:
--   
--   This module includes GHC rewrite rules to optimize <a>alterF</a> for
--   the <a>Const</a> and <a>Identity</a> functors. In general, these rules
--   improve performance. The sole exception is that when using
--   <a>Identity</a>, deleting a key that is already absent takes longer
--   than it would without the rules. If you expect this to occur a very
--   large fraction of the time, you might consider using a private copy of
--   the <a>Identity</a> type.
--   
--   Note: Unlike <tt>Data.Map.alterF</tt> for <a>Map</a>, <a>alterF</a> is
--   <i>not</i> a flipped version of the <a>at</a> combinator from
--   <a>Control.Lens.At</a>.
alterF :: (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> NEMap k a -> f (Map k a)

-- | <i>O(log n)</i>. Variant of <a>alter</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
alter' :: Ord k => (Maybe a -> a) -> k -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Variant of <a>alterF</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
--   
--   Like <tt>Data.Map.alterF</tt> for <a>Map</a>, can be used to
--   generalize and unify <a>lookup</a> and <a>insert</a>. However, because
--   it disallows deletion, it cannot be used to implement <a>delete</a>.
--   
--   See <a>alterF</a> for usage information and caveats.
--   
--   Note: Neither <a>alterF</a> nor <a>alterF'</a> can be considered
--   flipped versions of the <tt>at</tt> combinator from <a>At</a>.
alterF' :: (Ord k, Functor f) => (Maybe a -> f a) -> k -> NEMap k a -> f (NEMap k a)

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
--   
--   An example of using <tt>lookup</tt>:
--   
--   <pre>
--   import Prelude hiding (lookup)
--   import Data.Map.NonEmpty
--   
--   employeeDept = fromList (("John","Sales") :| [("Bob","IT")])
--   deptCountry = fromList (("IT","USA") :| [("Sales","France")])
--   countryCurrency = fromList (("USA", "Dollar") :| [("France", "Euro")])
--   
--   employeeCurrency :: String -&gt; Maybe String
--   employeeCurrency name = do
--       dept &lt;- lookup name employeeDept
--       country &lt;- lookup dept deptCountry
--       lookup country countryCurrency
--   
--   main = do
--       putStrLn $ "John's currency: " ++ (show (employeeCurrency "John"))
--       putStrLn $ "Pete's currency: " ++ (show (employeeCurrency "Pete"))
--   </pre>
--   
--   The output of this program:
--   
--   <pre>
--   John's currency: Just "Euro"
--   Pete's currency: Nothing
--   </pre>
lookup :: Ord k => k -> NEMap k a -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Returns <a>Nothing</a> when
--   the element can not be found.
--   
--   <pre>
--   fromList ((5, 'a') :| [(3, 'b')]) !? 1 == Nothing
--   </pre>
--   
--   <pre>
--   fromList ((5, 'a') :| [(3, 'b')]) !? 5 == Just 'a'
--   </pre>
(!?) :: Ord k => NEMap k a -> k -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList ((5,'a') :| [(3,'b')]) ! 1    Error: element not in the map
--   fromList ((5,'a') :| [(3,'b')]) ! 5 == 'a'
--   </pre>
(!) :: Ord k => NEMap k a -> k -> a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList ((5,'a') :| [(3,'b')])) == 'x'
--   findWithDefault 'x' 5 (fromList ((5,'a') :| [(3,'b')])) == 'a'
--   </pre>
findWithDefault :: Ord k => a -> k -> NEMap k a -> a

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
--   
--   <pre>
--   member 5 (fromList ((5,'a') :| [(3,'b')])) == True
--   member 1 (fromList ((5,'a') :| [(3,'b')])) == False
--   </pre>
member :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
--   
--   <pre>
--   notMember 5 (fromList ((5,'a') :| [(3,'b')])) == False
--   notMember 1 (fromList ((5,'a') :| [(3,'b')])) == True
--   </pre>
notMember :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Find largest key smaller than the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   lookupLT 4 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   </pre>
lookupLT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater than the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   lookupGT 5 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   </pre>
lookupGT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find largest key smaller or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   lookupLE 4 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   lookupLE 5 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   </pre>
lookupLE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList ((3,'a') :| [(5,'b')])) == Just (3, 'a')
--   lookupGE 4 (fromList ((3,'a') :| [(5,'b')])) == Just (5, 'b')
--   lookupGE 6 (fromList ((3,'a') :| [(5,'b')])) == Nothing
--   </pre>
lookupGE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | <i>O(1)</i>. The number of elements in the map.
--   
--   <pre>
--   size (singleton 1 'a')                          == 1
--   size (fromList ((1,'a') :| [(2,'c'), (3,'b')])) == 3
--   </pre>
size :: NEMap k a -> Int

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "a"), (7, "C")])
--   </pre>
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "aA"), (7, "C")])
--   </pre>
unionWith :: Ord k => (a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function,
--   given the matching key.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == fromList ((3, "b") :| [(5, "5:a|A"), (7, "C")])
--   </pre>
unionWithKey :: Ord k => (k -> a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a non-empty list of maps.
--   
--   <pre>
--   unions (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions (fromList ((5, "A3") :| [(3, "B3")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "a") :| [(3, "b")])])
--       == fromList ((3, "B3") :| [(5, "A3"), (7, "C")])
--   </pre>
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | The union of a non-empty list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl1</a> (<a>unionWith</a> f)</tt>).
--   
--   <pre>
--   unionsWith (++) (fromList ((5, "a") :| [(3, "b")]) :| [fromList ((5, "A") :| [(7, "C")]), fromList ((5, "A3") :| [(3, "B3")])])
--       == fromList ((3, "bB3") :| [(5, "aAA3"), (7, "C")])
--   </pre>
unionsWith :: (Foldable1 f, Ord k) => (a -> a -> a) -> f (NEMap k a) -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Difference of two maps. Return
--   elements of the first map not existing in the second map.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map.
--   
--   <pre>
--   difference (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 3 "b"
--   </pre>
difference :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | Same as <a>difference</a>.
(\\) :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the values
--   of these keys. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map and the function returns <a>Nothing</a> for
--   every pair.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(3, "B"), (7, "C")]))
--       == Data.Map.singleton 3 "b:B"
--   </pre>
differenceWith :: Ord k => (a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the first map is
--   a subset of the second map and the function returns <a>Nothing</a> for
--   every pair.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(3, "B"), (10, "C")]))
--       == Data.Map.singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection of two maps. Return
--   data in the first map for the keys existing in both maps.
--   (<tt><a>intersection</a> m1 m2 == <a>intersectionWith</a> <a>const</a>
--   m1 m2</tt>).
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   intersection (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "a"
--   </pre>
intersection :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   intersectionWith (++) (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "aA"
--   </pre>
intersectionWith :: Ord k => (a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
--   
--   Returns a potentially empty map (<a>Map</a>), in case the two maps
--   share no keys in common.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList ((5, "a") :| [(3, "b")])) (fromList ((5, "A") :| [(7, "C")])) == Data.Map.singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "bx") :| [(5, "ax")])
--   </pre>
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList ((5,"a") :| [(3,"b")])) == fromList ((3, "3:b") :| [(5, "5:a")])
--   </pre>
mapWithKey :: (k -> a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. Traverse keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), our function might
--   return <a>Nothing</a> on every item in the <a>NEMap</a>.
--   
--   <i>Use <a>traverseMaybeWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
traverseMaybeWithKey :: Applicative t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)

-- | <i>O(n)</i>. Traverse keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), our function might
--   return <a>Nothing</a> on every item in the <a>NEMap</a>.
--   
--   Is more general than <a>traverseWithKey</a>, since works with all
--   <a>Apply</a>, and not just <a>Applicative</a>.
traverseMaybeWithKey1 :: Apply t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)

-- | <i>O(n)</i>. The function <a>mapAccum</a> threads an accumulating
--   argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList ((5,"a") :| [(3,"b")])) == ("Everything: ba", fromList ((3, "bX") :| [(5, "aX")]))
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n)</i>. The function <a>mapAccumWithKey</a> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList ((5,"a") :| [(3,"b")])) == ("Everything: 3-b 5-a", fromList ((3, "bX") :| [(5, "aX")]))
--   </pre>
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n)</i>. The function <a>mapAccumRWithKey</a> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)

-- | <i>O(n*log n)</i>. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeys (+ 1) (fromList ((5,"a") :| [(3,"b")]))                        == fromList ((4, "b") :| [(6, "a")])
--   mapKeys (\ _ -&gt; 1) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 3 "c"
--   </pre>
mapKeys :: Ord k2 => (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n*log n)</i>. <tt><a>mapKeysWith</a> c f s</tt> is the map
--   obtained by applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>. The value at the greater of the two
--   original keys is used as the first argument to <tt>c</tt>.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList ((1,"b") :| [(2,"a"), (3,"d"), (4,"c")])) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   While the size of the result map may be smaller than the input map,
--   the output map is still guaranteed to be non-empty if the input map is
--   non-empty.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList ((5,"a") :| [(3,"b")])) == fromList ((6, "b") :| [(10, "a")])
--   valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList ((5,"a") :| [(3,"b")]))) == True
--   valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList ((5,"a") :| [(3,"b")]))) == False
--   </pre>
mapKeysMonotonic :: (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   <pre>
--   elemsList = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList ((5,"a") :| [(3,"bbb")])) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
foldrWithKey :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
foldlWithKey :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldrWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldrWithKey' :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldlWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldlWithKey' :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
--   
--   <pre>
--   elems (fromList ((5,"a") :| [(3,"b")])) == ("b" :| ["a"])
--   </pre>
elems :: NEMap k a -> NonEmpty a

-- | <i>O(n)</i>. Return all keys of the map in ascending order.
--   
--   <pre>
--   keys (fromList ((5,"a") :| [(3,"b")])) == (3 :| [5])
--   </pre>
keys :: NEMap k a -> NonEmpty k

-- | <i>O(n)</i>. An alias for <a>toAscList</a>. Return all key/value pairs
--   in the map in ascending key order.
--   
--   <pre>
--   assocs (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
assocs :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
--   
--   <pre>
--   toList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   toAscList (fromList ((5,"a") :| [(3,"b")])) == ((3,"b") :| [(5,"a")])
--   </pre>
toAscList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in descending order.
--   
--   <pre>
--   toDescList (fromList ((5,"a") :| [(3,"b")])) == ((5,"a") :| [(3,"b")])
--   </pre>
toDescList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
--   
--   Returns a potentially empty map (<a>Map</a>), because we could
--   potentailly filter out all items in the original <a>NEMap</a>.
--   
--   <pre>
--   filter (&gt; "a") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   filter (&gt; "x") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.empty
--   filter (&lt; "a") (fromList ((5,"a") :| [(3,"b")])) == Data.Map.empty
--   </pre>
filter :: (a -> Bool) -> NEMap k a -> Map k a

-- | <i>O(n)</i>. Filter all keys/values that satisfy the predicate.
--   
--   Returns a potentially empty map (<a>Map</a>), because we could
--   potentailly filter out all items in the original <a>NEMap</a>.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
filterWithKey :: (k -> a -> Bool) -> NEMap k a -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Restrict an <a>NEMap</a> to only
--   those keys found in a <a>Set</a>.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>member</a>` s) m
--   m `restrictKeys` s = m `<a>intersection</a>` <tt>fromSet</tt> (const ()) s
--   </pre>
restrictKeys :: Ord k => NEMap k a -> Set k -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Remove all keys in a <tt>Set</tt>
--   from an <a>NEMap</a>.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>notMember</a>` s) m
--   m `withoutKeys` s = m `<a>difference</a>` <tt>fromSet</tt> (const ()) s
--   </pre>
withoutKeys :: Ord k => NEMap k a -> Set k -> Map k a

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList ((5,"a") :| [(3,"b")])) == These (singleton 3 "b") (singleton 5 "a")
--   partition (&lt; "x") (fromList ((5,"a") :| [(3,"b")])) == This  (fromList ((3, "b") :| [(5, "a")]))
--   partition (&gt; "x") (fromList ((5,"a") :| [(3,"b")])) == That  (fromList ((3, "b") :| [(5, "a")]))
--   </pre>
partition :: (a -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(n)</i>. Partition the map according to a predicate.
--   
--   Returns a <a>These</a> with potentially two maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate was true for all
--   items, returning the original map.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate was false for all
--   items, returning the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (all of the items
--   that were true for the predicate) and <tt>n2</tt> (all of the items
--   that were false for the predicate).</li>
--   </ul>
--   
--   See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList ((5,"a") :| [(3,"b")])) == These (singleton 5 "a") (singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList ((5,"a") :| [(3,"b")])) == This  (fromList ((3, "b") :| [(5, "a")]))
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList ((5,"a") :| [(3,"b")])) == That  (fromList ((3, "b") :| [(5, "a")]))
--   </pre>
partitionWithKey :: (k -> a -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(log n)</i>. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   Returns a potentially empty map (<a>Map</a>), because the predicate
--   might fail on the first input.
--   
--   <pre>
--   takeWhileAntitone p = Data.Map.fromDistinctAscList . Data.List.takeWhile (p . fst) . Data.Foldable.toList
--   takeWhileAntitone p = <a>filterWithKey</a> (k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = Data.Map.fromDistinctAscList . Data.List.dropWhile (p . fst) . Data.Foldable.toList
--   dropWhileAntitone p = <a>filterWithKey</a> (k -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Divide a map at the point where a predicate on the
--   keys stops holding. The user is responsible for ensuring that for all
--   keys <tt>j</tt> and <tt>k</tt> in the map, <tt>j &lt; k ==&gt; p j
--   &gt;= p k</tt>.
--   
--   Returns a <a>These</a> with potentially two maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the predicate never failed for
--   any item, returning the original map.</li>
--   <li><tt><a>That</a> n2</tt> means that the predicate failed for the
--   first item, returning the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map up to the
--   point where the predicate on the keys stops holding) and <tt>n2</tt>
--   (the map starting from the point where the predicate stops
--   holding)</li>
--   </ul>
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = partitionWithKey (k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point where the predicate switches from holding to not holding (where
--   the predicate is seen to hold before the first key and to fail after
--   the last key).
spanAntitone :: (k -> Bool) -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), because the function
--   could potentially return <a>Nothing</a> on all items in the
--   <a>NEMap</a>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> NEMap k a -> Map k b

-- | <i>O(n)</i>. Map keys/values and collect the <a>Just</a> results.
--   
--   Returns a potentially empty map (<a>Map</a>), because the function
--   could potentially return <a>Nothing</a> on all items in the
--   <a>NEMap</a>.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (k -> a -> Maybe b) -> NEMap k a -> Map k b

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   Returns a <a>These</a> with potentially two maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the results were all
--   <a>Left</a>.</li>
--   <li><tt><a>That</a> n2</tt> means that the results were all
--   <a>Right</a>.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map where the
--   results were <a>Left</a>) and <tt>n2</tt> (the map where the results
--   were <a>Right</a>)</li>
--   </ul>
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == These (fromList ((3,"b") :| [(5,"a")])) (fromList ((1,"x") :| [(7,"z")]))
--   
--   mapEither (\ a -&gt; Right a) (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == That (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--   </pre>
mapEither :: (a -> Either b c) -> NEMap k a -> These (NEMap k b) (NEMap k c)

-- | <i>O(n)</i>. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   Returns a <a>These</a> with potentially two maps:
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that the results were all
--   <a>Left</a>.</li>
--   <li><tt><a>That</a> n2</tt> means that the results were all
--   <a>Right</a>.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (the map where the
--   results were <a>Left</a>) and <tt>n2</tt> (the map where the results
--   were <a>Right</a>)</li>
--   </ul>
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == These (fromList ((1,2) :| [(3,6)])) (fromList ((5,"aa") :| [(7,"zz")]))
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList ((5,"a") :| [(3,"b"), (1,"x"), (7,"z")]))
--       == That (fromList ((1,"x") :| [(3,"b"), (5,"a"), (7,"z")]))
--   </pre>
mapEitherWithKey :: (k -> a -> Either b c) -> NEMap k a -> These (NEMap k b) (NEMap k c)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> k map</tt>) is
--   potentially a <a>These</a> containing up to two <a>NEMap</a>s based on
--   splitting the map into maps containing items before and after the
--   given key <tt>k</tt>. It will never return a map that contains
--   <tt>k</tt> itself.
--   
--   <ul>
--   <li><a>Nothing</a> means that <tt>k</tt> was the only key in the the
--   original map, and so there are no items before or after it.</li>
--   <li><tt><a>Just</a> (<a>This</a> n1)</tt> means <tt>k</tt> was larger
--   than all items in the map, and <tt>n1</tt> is the entire original
--   map.</li>
--   <li><tt><a>Just</a> (<a>That</a> n2)</tt> means <tt>k</tt> was smaller
--   than all items in the map, and <tt>n2</tt> is the entire original
--   map.</li>
--   <li><tt><a>Just</a> (<a>These</a> n1 n2)</tt> gives <tt>n1</tt> (the
--   map of all keys from the original map less than <tt>k</tt>) and
--   <tt>n2</tt> (the map of all keys from the original map greater than
--   <tt>k</tt>)</li>
--   </ul>
--   
--   <pre>
--   split 2 (fromList ((5,"a") :| [(3,"b")])) == Just (That  (fromList ((3,"b") :| [(5,"a")]))  )
--   split 3 (fromList ((5,"a") :| [(3,"b")])) == Just (That  (singleton 5 "a")                  )
--   split 4 (fromList ((5,"a") :| [(3,"b")])) == Just (These (singleton 3 "b") (singleton 5 "a"))
--   split 5 (fromList ((5,"a") :| [(3,"b")])) == Just (This  (singleton 3 "b")                  )
--   split 6 (fromList ((5,"a") :| [(3,"b")])) == Just (This  (fromList ((3,"b") :| [(5,"a")]))  )
--   split 5 (singleton 5 "a")                 == Nothing
--   </pre>
split :: Ord k => k -> NEMap k a -> Maybe (These (NEMap k a) (NEMap k a))

-- | <i>O(log n)</i>. The expression (<tt><a>splitLookup</a> k map</tt>)
--   splits a map just like <a>split</a> but also returns <tt><a>lookup</a>
--   k map</tt>, as a <tt><a>Maybe</a> a</tt>.
--   
--   <pre>
--   splitLookup 2 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (That  (fromList ((3,"b") :| [(5,"a")]))))
--   splitLookup 3 (fromList ((5,"a") :| [(3,"b")])) == (Just "b", Just (That  (singleton 5 "a")))
--   splitLookup 4 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (These (singleton 3 "b") (singleton 5 "a")))
--   splitLookup 5 (fromList ((5,"a") :| [(3,"b")])) == (Just "a", Just (This  (singleton 3 "b"))
--   splitLookup 6 (fromList ((5,"a") :| [(3,"b")])) == (Nothing , Just (This  (fromList ((3,"b") :| [(5,"a")])))
--   splitLookup 5 (singleton 5 "a")                 == (Just "a", Nothing)
--   </pre>
splitLookup :: Ord k => k -> NEMap k a -> (Maybe a, Maybe (These (NEMap k a) (NEMap k a)))

-- | <i>O(1)</i>. Decompose a map into pieces based on the structure of the
--   underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Note that the current implementation does not return more than four
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: NEMap k a -> NonEmpty (NEMap k a)

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. This function is defined as
--   (<tt><a>isSubmapOf</a> = <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression
--   (<tt><a>isSubmapOfBy</a> f t1 t2</tt>) returns <a>True</a> if all keys
--   in <tt>t1</tt> are in tree <tt>t2</tt>, and when <tt>f</tt> returns
--   <a>True</a> when applied to their respective values. For example, the
--   following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (&lt;=) (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (==) (fromList (('a',1) :| [('b',2)])) (fromList (('a',1) :| [('b',2)]))
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (singleton 'a' 2) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (&lt;)  (singleton 'a' 1) (fromList (('a',1) :| [('b',2)]))
--   isSubmapOfBy (==) (fromList (('a',1) :| [('b',2)])) (singleton 'a' 1)
--   </pre>
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Is this a proper submap? (ie. a
--   submap but not equal). Defined as (<tt><a>isProperSubmapOf</a> =
--   <a>isProperSubmapOfBy</a> (==)</tt>).
isProperSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Is this a proper submap? (ie. a
--   submap but not equal). The expression (<tt><a>isProperSubmapOfBy</a> f
--   m1 m2</tt>) returns <a>True</a> when <tt>m1</tt> and <tt>m2</tt> are
--   not equal, all keys in <tt>m1</tt> are in <tt>m2</tt>, and when
--   <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (singleton 1 1) (fromList ((1,1) :| [(2,2)]))
--   isProperSubmapOfBy (&lt;=) (singleton 1 1) (fromList ((1,1) :| [(2,2)]))
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList ((1,1) :| [(2,2)])) (fromList ((1,1) :| [(2,2)]))
--   isProperSubmapOfBy (==) (fromList ((1,1) :| [(2,2)])) (singleton 1 1))
--   isProperSubmapOfBy (&lt;)  (singleton 1 1)               (fromList ((1,1) :| [(2,2)]))
--   </pre>
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool

-- | <i>O(log n)</i>. Lookup the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   
--   <pre>
--   isJust (lookupIndex 2 (fromList ((5,"a") :| [(3,"b")])))   == False
--   fromJust (lookupIndex 3 (fromList ((5,"a") :| [(3,"b")]))) == 0
--   fromJust (lookupIndex 5 (fromList ((5,"a") :| [(3,"b")]))) == 1
--   isJust (lookupIndex 6 (fromList ((5,"a") :| [(3,"b")])))   == False
--   </pre>
lookupIndex :: Ord k => k -> NEMap k a -> Maybe Int

-- | <i>O(log n)</i>. Return the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   Calls <a>error</a> when the key is not a <a>member</a> of the map.
--   
--   <pre>
--   findIndex 2 (fromList ((5,"a") :| [(3,"b")]))    Error: element is not in the map
--   findIndex 3 (fromList ((5,"a") :| [(3,"b")])) == 0
--   findIndex 5 (fromList ((5,"a") :| [(3,"b")])) == 1
--   findIndex 6 (fromList ((5,"a") :| [(3,"b")]))    Error: element is not in the map
--   </pre>
findIndex :: Ord k => k -> NEMap k a -> Int

-- | <i>O(log n)</i>. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList ((5,"a") :| [(3,"b")])) == (3,"b")
--   elemAt 1 (fromList ((5,"a") :| [(3,"b")])) == (5, "a")
--   elemAt 2 (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   </pre>
elemAt :: Int -> NEMap k a -> (k, a)

-- | <i>O(log n)</i>. Variant of <a>updateAt</a> that disallows deletion.
--   Allows us to guarantee that the result is also a non-empty Map.
adjustAt :: (k -> a -> a) -> Int -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Update the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   Returns a possibly empty map (<a>Map</a>), because the function might
--   end up deleting the last key in the map. See <a>adjustAt</a> for a
--   version that disallows deletion, guaranteeing that the result is also
--   a non-empty Map.
--   
--   <pre>
--   updateAt (\ _ _ -&gt; Just "x") 0    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "x"), (5, "a")]
--   updateAt (\ _ _ -&gt; Just "x") 1    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "x")]
--   updateAt (\ _ _ -&gt; Just "x") 2    (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\ _ _ -&gt; Just "x") (-1) (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  0    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   updateAt (\_ _  -&gt; Nothing)  1    (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   updateAt (\_ _  -&gt; Nothing)  2    (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  (-1) (fromList ((5,"a") :| [(3,"b")]))    Error: index out of range
--   </pre>
updateAt :: (k -> a -> Maybe a) -> Int -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   Returns a potentially empty map (<a>Map</a>) because of the
--   possibility of deleting the last item in a map.
--   
--   <pre>
--   deleteAt 0  (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   deleteAt 1  (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   deleteAt 2 (fromList ((5,"a") :| [(3,"b")]))     Error: index out of range
--   deleteAt (-1) (fromList ((5,"a") :| [(3,"b")]))  Error: index out of range
--   </pre>
deleteAt :: Int -> NEMap k a -> Map k a

-- | Take a given number of entries in key order, beginning with the
--   smallest keys.
--   
--   Returns a possibly empty map (<a>Map</a>), in case we take zero
--   elements.
--   
--   <pre>
--   take n = <a>fromDistinctAscList</a> . <a>take</a> n . Foldable.toList . <a>toList</a>
--   </pre>
take :: Int -> NEMap k a -> Map k a

-- | Drop a given number of entries in key order, beginning with the
--   smallest keys.
--   
--   Returns a possibly empty map (<a>Map</a>), in case we drop all of the
--   elements.
--   
--   <pre>
--   drop n = <a>fromDistinctAscList</a> . <a>drop</a> n . Foldable.toList . <a>toList</a>
--   </pre>
drop :: Int -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Split a map at a particular index <tt>i</tt>.
--   
--   <ul>
--   <li><tt><a>This</a> n1</tt> means that there are less than <tt>i</tt>
--   items in the map, and <tt>n1</tt> is the original map.</li>
--   <li><tt><a>That</a> n2</tt> means <tt>i</tt> was 0; we dropped 0
--   items, so <tt>n2</tt> is the original map.</li>
--   <li><tt><a>These</a> n1 n2</tt> gives <tt>n1</tt> (taking <tt>i</tt>
--   items from the original map) and <tt>n2</tt> (dropping <tt>i</tt>
--   items from the original map))</li>
--   </ul>
splitAt :: Int -> NEMap k a -> These (NEMap k a) (NEMap k a)

-- | <i>O(1)</i>. The minimal key of the map. Note that this is total,
--   making <a>lookupMin</a> obsolete. It is constant-time, so has better
--   asymptotics than <a>lookupMin</a> and <a>findMin</a>, as well.
--   
--   <pre>
--   findMin (fromList ((5,"a") :| [(3,"b")])) == (3,"b")
--   </pre>
findMin :: NEMap k a -> (k, a)

-- | <i>O(log n)</i>. The maximal key of the map. Note that this is total,
--   making <a>lookupMin</a> obsolete. It is constant-time, so has better
--   asymptotics than <a>lookupMin</a> and <a>findMin</a>, as well.
--   
--   <pre>
--   findMin (fromList ((5,"a") :| [(3,"b")])) == (3,"b")
--   </pre>
findMax :: NEMap k a -> (k, a)

-- | <i>O(1)</i>. Delete the minimal key. Returns a potentially empty map
--   (<a>Map</a>), because we might end up deleting the final key in the
--   map. It is constant-time, so has better asymptotics than
--   <a>deleteMin</a>.
--   
--   <pre>
--   deleteMin (fromList ((5,"a") :| [(3,"b"), (7,"c")])) == Data.Map.fromList [(5,"a"), (7,"c")]
--   deleteMin (singleton 5 "a") == Data.Map.empty
--   </pre>
deleteMin :: NEMap k a -> Map k a

-- | <i>O(log n)</i>. Delete the maximal key. Returns a potentially empty
--   map (<a>Map</a>), because we might end up deleting the final key in
--   the map.
--   
--   <pre>
--   deleteMax (fromList ((5,"a") :| [(3,"b"), (7,"c")])) == Data.Map.fromList [(3,"b"), (5,"a")]
--   deleteMax (singleton 5 "a") == Data.Map.empty
--   </pre>
deleteMax :: NEMap k a -> Map k a

-- | <i>O(1)</i>. Delete and find the minimal key-value pair. It is
--   constant-time, so has better asymptotics that <a>minView</a> for
--   <a>Map</a>.
--   
--   Note that unlike <a>deleteFindMin</a> for <a>Map</a>, this cannot ever
--   fail, and so is a total function. However, the result <a>Map</a> is
--   potentially empty, since the original map might have contained just a
--   single item.
--   
--   <pre>
--   deleteFindMin (fromList ((5,"a") :| [(3,"b"), (10,"c")])) == ((3,"b"), Data.Map.fromList [(5,"a"), (10,"c")])
--   </pre>
deleteFindMin :: NEMap k a -> ((k, a), Map k a)

-- | <i>O(log n)</i>. Delete and find the minimal key-value pair.
--   
--   Note that unlike <a>deleteFindMax</a> for <a>Map</a>, this cannot ever
--   fail, and so is a total function. However, the result <a>Map</a> is
--   potentially empty, since the original map might have contained just a
--   single item.
--   
--   <pre>
--   deleteFindMax (fromList ((5,"a") :| [(3,"b"), (10,"c")])) == ((10,"c"), Data.Map.fromList [(3,"b"), (5,"a")])
--   </pre>
deleteFindMax :: NEMap k a -> ((k, a), Map k a)

-- | <i>O(1)</i> if delete, <i>O(log n)</i> otherwise. Update the value at
--   the minimal key. Returns a potentially empty map (<a>Map</a>), because
--   we might end up deleting the final key in the map if the function
--   returns <a>Nothing</a>. See <a>adjustMin</a> for a version that can
--   guaruntee that we return a non-empty map.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update the value at the maximal key. Returns a
--   potentially empty map (<a>Map</a>), because we might end up deleting
--   the final key in the map if the function returns <a>Nothing</a>. See
--   <a>adjustMax</a> for a version that can guarantee that we return a
--   non-empty map.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(1)</i>. A version of <a>updateMin</a> that disallows deletion,
--   allowing us to guarantee that the result is also non-empty.
adjustMin :: (a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. A version of <a>updateMax</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
adjustMax :: (a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(1)</i> if delete, <i>O(log n)</i> otherwise. Update the value at
--   the minimal key. Returns a potentially empty map (<a>Map</a>), because
--   we might end up deleting the final key in the map if the function
--   returns <a>Nothing</a>. See <a>adjustMinWithKey</a> for a version that
--   guaruntees a non-empty map.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMinWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(log n)</i>. Update the value at the maximal key. Returns a
--   potentially empty map (<a>Map</a>), because we might end up deleting
--   the final key in the map if the function returns <a>Nothing</a>. See
--   <a>adjustMaxWithKey</a> for a version that guaruntees a non-empty map.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList ((5,"a") :| [(3,"b")])) == Data.Map.fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList ((5,"a") :| [(3,"b")])) == Data.Map.singleton 5 "a"
--   </pre>
updateMaxWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a

-- | <i>O(1)</i>. A version of <a>adjustMaxWithKey</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
--   Note that it also is able to have better asymptotics than
--   <a>updateMinWithKey</a> in general.
adjustMinWithKey :: (k -> a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. A version of <a>updateMaxWithKey</a> that disallows
--   deletion, allowing us to guarantee that the result is also non-empty.
adjustMaxWithKey :: (k -> a -> a) -> NEMap k a -> NEMap k a

-- | <i>O(1)</i>. Retrieves the value associated with minimal key of the
--   map, and the map stripped of that element. It is constant-time, so has
--   better asymptotics than <a>minView</a> for <a>Map</a>.
--   
--   Note that unlike <a>minView</a> for <a>Map</a>, this cannot ever fail,
--   so doesn't need to return in a <a>Maybe</a>. However, the result
--   <a>Map</a> is potentially empty, since the original map might have
--   contained just a single item.
--   
--   <pre>
--   minView (fromList ((5,"a") :| [(3,"b")])) == ("b", Data.Map.singleton 5 "a")
--   </pre>
minView :: NEMap k a -> (a, Map k a)

-- | <i>O(log n)</i>. Retrieves the value associated with maximal key of
--   the map, and the map stripped of that element.
--   
--   Note that unlike <a>maxView</a> from <a>Map</a>, this cannot ever
--   fail, so doesn't need to return in a <a>Maybe</a>. However, the result
--   <a>Map</a> is potentially empty, since the original map might have
--   contained just a single item.
--   
--   <pre>
--   maxView (fromList ((5,"a") :| [(3,"b")])) == ("a", Data.Map.singleton 3 "b")
--   </pre>
maxView :: NEMap k a -> (a, Map k a)

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
