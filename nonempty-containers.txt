-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-empty variants of containers data types, with full API
--   
--   Efficient and optimized non-empty versions of types from
--   <i>containers</i>. Inspired by <i>non-empty-containers</i> library,
--   except attempting a more faithful port (with under-the-hood
--   optimizations) of the full <i>containers</i> API.
@package nonempty-containers
@version 0.1.0.0


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   This contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
module Data.Map.NonEmpty.Internal

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <tt>insert</tt>) return <a>NEMap</a>, but functions
--   that might potentially return an empty map (like <tt>delete</tt>)
--   return a <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <tt>insertMap</tt> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a (non-empty) <a>Map</a> with
--   <a>toMap</a>.
data NEMap k a
NEMap :: !k -> a -> !Map k a -> NEMap k a

-- | invariant: must be smaller than smallest key in map
[nemK0] :: NEMap k a -> !k
[nemV0] :: NEMap k a -> a
[nemMap] :: NEMap k a -> !Map k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: k -> a -> NEMap k a

-- | <i>O(log n)</i> Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <tt>fromAscList</tt>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
toList :: NEMap k a -> NonEmpty (k, a)
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <tt>unionWith</tt>
--   <a>const</a></tt>).
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a list of maps.
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
elems :: NEMap k a -> NonEmpty a

-- | <i>O(1)</i>. The number of elements in the map.
size :: NEMap k a -> Int

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
toMap :: NEMap k a -> Map k a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A version of <a>foldr</a> that uses the value at the
--   maximal key in the map as the starting value.
--   
--   Note that, unlike <a>foldr1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldr1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <tt>fromNonEmpty</tt>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <tt>fromNonEmpty</tt>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <tt>mapWithKey</tt> f
--   </pre>
--   
--   This can be an asymptotically faster than <tt>foldrWithKey</tt> or
--   <tt>foldlWithKey</tt> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly greater than</i> the new key. That is, the new key must be
--   <i>strictly less than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <a>insert</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
insertMinMap :: k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert new key and value into a map where keys are
--   <i>strictly less than</i> the new key. That is, the new key must be
--   <i>strictly greater than</i> all keys present in the <a>Map</a>. /The
--   precondition is not checked./
--   
--   While this has the same asymptotics as <a>insert</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
insertMaxMap :: k -> a -> Map k a -> Map k a

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.NonEmpty.Internal.NEMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.NonEmpty.Internal.NEMap k a)
instance Data.Functor.Classes.Eq2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Eq k => Data.Functor.Classes.Eq1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Ord2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Functor.Classes.Show2 Data.Map.NonEmpty.Internal.NEMap
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k) => Data.Functor.Classes.Read1 (Data.Map.NonEmpty.Internal.NEMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read e) => GHC.Read.Read (Data.Map.NonEmpty.Internal.NEMap k e)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.NonEmpty.Internal.NEMap k a)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Data.Map.NonEmpty.Internal.NEMap k a)
instance GHC.Base.Functor (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Foldable.Foldable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Traversable.Traversable (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Map.NonEmpty.Internal.NEMap k)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Map.NonEmpty.Internal.NEMap k)

module Data.Map.NonEmpty

-- | A non-empty Map from keys <tt>k</tt> to values <tt>a</tt>. At least
--   one key-value pair exists in an <tt><a>NEMap</a> k v</tt> at all
--   times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <tt>insert</tt>) return <a>NEMap</a>, but functions
--   that might potentially return an empty map (like <tt>delete</tt>)
--   return a <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <tt>insertMap</tt> family of functions to insert a
--   value into a <a>Map</a> to create a guarunteed <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a (non-empty) <a>Map</a> with
--   <a>toMap</a>.
data NEMap k a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | <i>O(log n)</i>. The <a>NonEmptyMap</a> and <a>EmptyMap</a> patterns
--   allow you to treat a <a>Map</a> as if it were either a
--   <tt><a>NonEmptyMap</a> n</tt> (where <tt>n</tt> is a <a>NEMap</a>) or
--   an <a>EmptyMap</a>.
--   
--   For example, you can pattern match on a <a>Map</a>:
--   
--   <pre>
--   myFunc :: <a>Map</a> K X -&gt; Y
--   myFunc m = case m of
--       <a>NonEmptyMap</a> n -&gt; -- here, n is a <a>NonEmptyMap</a>, m is proven not empty.
--       <a>EmptyMap</a>      -&gt; -- here, m is empty.
--   </pre>
--   
--   Matching on <tt><a>NonEmptyMap</a> n</tt> means that the original
--   <a>Map</a> was <i>not</i> empty, and you have a verified-non-empty
--   <a>NEMap</a> <tt>n</tt> to use.
--   
--   Note that patching on this pattern is <i>O(1)</i>. However, using the
--   contents requires a <i>O(log n)</i> cost that is deferred until after
--   the pattern is matched on (and is not incurred at all if the contents
--   are never used).
pattern NonEmptyMap :: NEMap k a -> Map k a

-- | <i>O(1)</i>. The <a>NonEmptyMap</a> and <a>EmptyMap</a> patterns allow
--   you to treat a <a>Map</a> as if it were either a
--   <tt><a>NonEmptyMap</a> n</tt> (where <tt>n</tt> is a <a>NEMap</a>) or
--   an <a>EmptyMap</a>.
--   
--   Matching on <a>EmptyMap</a> means that the original <a>Map</a> was
--   empty.
--   
--   See <a>NonEmptyMap</a> for more information.
pattern EmptyMap :: Map k a

-- | <i>O(log n)</i> Smart constructor for an <a>NEMap</a> from a
--   <a>Map</a>. Returns <a>Nothing</a> if the <a>Map</a> was originally
--   actually empty, and <tt><a>Just</a> n</tt> with an <a>NEMap</a>, if
--   the <a>Map</a> was not empty.
nonEmptyMap :: Map k a -> Maybe (NEMap k a)

-- | <i>O(log n)</i>. Convert a non-empty map back into a normal
--   possibly-empty map, for usage with functions that expect <a>Map</a>.
toMap :: NEMap k a -> Map k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. If key is already present, will overwrite the original
--   value.
--   
--   See <a>insertMapMin</a> for a version that is constant-time if the new
--   key is <i>strictly smaller than</i> all keys in the original map.
insertMap :: Ord k => k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Uses a combining function with the new value as the
--   first argument if the key is already present.
insertMapWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i>. Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair. Uses a combining function with the key and new value
--   as the first and second arguments if the key is already present.
insertMapWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> NEMap k a

-- | <i>O(1)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly less than</i> all keys in
--   the input map. The keys in the original map must all be <i>strictly
--   greater than</i> the new key. <i>The precondition is not checked.</i>
insertMapMin :: k -> a -> Map k a -> NEMap k a

-- | <i>O(log n)</i> Convert a <a>Map</a> into an <a>NEMap</a> by adding a
--   key-value pair where the key is <i>strictly greater than</i> all keys
--   in the input map. The keys in the original map must all be <i>strictly
--   less than</i> the new key. <i>The precondition is not checked.</i>
--   
--   While this has the same asymptotics as <a>insertMap</a>, it saves a
--   constant factor for key comparison (so may be helpful if comparison is
--   expensive) and also does not require an <a>Ord</a> instance for the
--   key type.
insertMapMax :: k -> a -> Map k a -> NEMap k a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | <i>O(1)</i>. A map with a single element.
singleton :: k -> a -> NEMap k a

-- | <i>O(n*log n)</i>. Build a non-empty map from a non-empty list of
--   key/value pairs. See also <tt>fromAscList</tt>. If the list contains
--   more than one value for the same key, the last value for the key is
--   retained.
fromList :: Ord k => NonEmpty (k, a) -> NEMap k a
fromListWith :: Ord k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromAscList :: Eq k => NonEmpty (k, a) -> NEMap k a
fromAscListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromDistinctAscList :: NonEmpty (k, a) -> NEMap k a
fromDescList :: Eq k => NonEmpty (k, a) -> NEMap k a
fromDescListWith :: Eq k => (a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> NonEmpty (k, a) -> NEMap k a
fromDistinctDescList :: NonEmpty (k, a) -> NEMap k a
insert :: Ord k => k -> a -> NEMap k a -> NEMap k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
insertWith :: Ord k => (a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> NEMap k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> NEMap k a -> (Maybe a, NEMap k a)
delete :: Ord k => k -> NEMap k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> NEMap k a -> NEMap k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> NEMap k a -> NEMap k a
update :: Ord k => (a -> Maybe a) -> k -> NEMap k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> NEMap k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> NEMap k a -> Map k a
alterF :: (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> NEMap k a -> f (Map k a)

-- | Variant of <a>alter</a> that disallows deletion. Allows us to
--   guarantee that the result is also a non-empty Map.
alter' :: Ord k => (Maybe a -> a) -> k -> NEMap k a -> NEMap k a

-- | Variant of <a>alterF</a> that disallows deletion. Allows us to
--   guarantee that the result is also a non-empty Map.
--   
--   TODO: RULES
alterF' :: (Ord k, Functor f) => (Maybe a -> f a) -> k -> NEMap k a -> f (NEMap k a)

-- | <i>O(log n)</i>. Find largest key smaller than the given one and
--   return the corresponding (key, value) pair.
lookup :: Ord k => k -> NEMap k a -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Returns <a>Nothing</a> when
--   the element can not be found.
(!?) :: Ord k => NEMap k a -> k -> Maybe a

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
(!) :: Ord k => NEMap k a -> k -> a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: Ord k => a -> k -> NEMap k a -> a

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: Ord k => k -> NEMap k a -> Bool

-- | <i>O(log n)</i>. Find largest key smaller than the given one and
--   return the corresponding (key, value) pair.
lookupLT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater than the given one and
--   return the corresponding (key, value) pair.
lookupGT :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find largest key smaller or equal to the given one
--   and return the corresponding (key, value) pair.
lookupLE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Find smallest key greater or equal to the given one
--   and return the corresponding (key, value) pair.
lookupGE :: Ord k => k -> NEMap k a -> Maybe (k, a)

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | <i>O(1)</i>. The number of elements in the map.
size :: NEMap k a -> Int

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <tt>unionWith</tt>
--   <a>const</a></tt>).
union :: Ord k => NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function.
unionWith :: Ord k => (a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Union with a combining function,
--   given the matching key.
unionWithKey :: Ord k => (k -> a -> a -> a) -> NEMap k a -> NEMap k a -> NEMap k a

-- | The left-biased union of a list of maps.
unions :: (Foldable1 f, Ord k) => f (NEMap k a) -> NEMap k a

-- | The union of a list of maps, with a combining operation.
unionsWith :: (Foldable1 f, Ord k) => (a -> a -> a) -> f (NEMap k a) -> NEMap k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Difference of two maps. Return
--   elements of the first map not existing in the second map.
difference :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | Same as <a>difference</a>.
(\\) :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the values
--   of these keys. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
differenceWith :: Ord k => (a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection of two maps. Return
--   data in the first map for the keys existing in both maps.
--   (<tt><a>intersection</a> m1 m2 == <a>intersectionWith</a> <a>const</a>
--   m1 m2</tt>).
intersection :: Ord k => NEMap k a -> NEMap k b -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
intersectionWith :: Ord k => (a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Intersection with a combining
--   function.
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> NEMap k a -> NEMap k b -> Map k c
map :: (a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. Map a function over all values in the map.
mapWithKey :: (k -> a -> b) -> NEMap k a -> NEMap k b

-- | <i>O(n)</i>. <tt><a>traverseWithKey1</a> f m == <tt>fromNonEmpty</tt>
--   <a>$</a> <a>traverse1</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse1</a> except that
--   the traversing function also has access to the key associated with a
--   value.
traverseWithKey1 :: Apply t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f m == <tt>fromNonEmpty</tt>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <i>Use <a>traverseWithKey1</a></i> whenever possible (if your
--   <a>Applicative</a> also has <a>Apply</a> instance). This version is
--   provided only for types that do not have <a>Apply</a> instance, since
--   <a>Apply</a> is not at the moment (and might not ever be) an official
--   superclass of <a>Applicative</a>.
--   
--   <pre>
--   <a>traverseWithKey</a> f = <a>unwrapApplicative</a> . <a>traverseWithKey1</a> (\k -&gt; WrapApplicative . f k)
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> NEMap k a -> t (NEMap k b)
traverseMaybeWithKey :: Apply t => (k -> a -> t (Maybe b)) -> NEMap k a -> t (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> NEMap k b -> (a, NEMap k c)
mapKeys :: Ord k2 => (k1 -> k2) -> NEMap k1 a -> NEMap k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> NEMap k1 a -> NEMap k2 a
mapKeysMonotonic :: (k1 -> k2) -> NEMap k1 a -> NEMap k2 a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
foldr :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
foldl :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
foldrWithKey :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keysList = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
foldlWithKey :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   semigroup, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold1</a> . <tt>mapWithKey</tt> f
--   </pre>
--   
--   This can be an asymptotically faster than <tt>foldrWithKey</tt> or
--   <tt>foldlWithKey</tt> for some monoids.
foldMapWithKey :: Semigroup m => (k -> a -> m) -> NEMap k a -> m

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. A version of <a>foldl</a> that uses the value at the
--   minimal key in the map as the starting value.
--   
--   Note that, unlike <a>foldl1</a> for <a>Map</a>, this function is total
--   if the input function is total.
foldl1 :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldl1</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl1' :: (a -> a -> a) -> NEMap k a -> a

-- | <i>O(n)</i>. A strict version of <a>foldrWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldrWithKey' :: (k -> a -> b -> b) -> b -> NEMap k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldlWithKey</a>. Each application
--   of the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldlWithKey' :: (a -> k -> b -> a) -> a -> NEMap k b -> a

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys.
elems :: NEMap k a -> NonEmpty a

-- | <i>O(n)</i>. Return all keys of the map in ascending order.
keys :: NEMap k a -> NonEmpty k

-- | <i>O(n)</i>. An alias for <a>toAscList</a>. Return all key/value pairs
--   in the map in ascending key order.
assocs :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a non-empty list of key/value pairs.
toList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in ascending order.
toAscList :: NEMap k a -> NonEmpty (k, a)

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in descending order.
toDescList :: NEMap k a -> NonEmpty (k, a)
filter :: (a -> Bool) -> NEMap k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> NEMap k a -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Restrict an <a>NEMap</a> to only
--   those keys found in a <tt>Set</tt>.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>member</a>` s) m
--   m `restrictKeys` s = m `<tt>intersect</tt>` <tt>fromSet</tt> (const ()) s
--   </pre>
restrictKeys :: Ord k => NEMap k a -> Set k -> Map k a

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. Remove all keys in a <tt>Set</tt>
--   from an <a>NEMap</a>.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (k _ -&gt; k `<a>notMember</a>` s) m
--   m `withoutKeys` s = m `<a>difference</a>` <tt>fromSet</tt> (const ()) s
--   </pre>
withoutKeys :: Ord k => NEMap k a -> Set k -> Map k a
partition :: (a -> Bool) -> NEMap k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> NEMap k a -> (Map k a, Map k a)
takeWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> NEMap k a -> Map k a
spanAntitone :: (k -> Bool) -> NEMap k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> NEMap k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> NEMap k a -> Map k b
mapEither :: (a -> Either b c) -> NEMap k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> NEMap k a -> (Map k b, Map k c)
split :: Ord k => k -> NEMap k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> NEMap k a -> (Map k a, Maybe a, Map k a)
splitRoot :: NEMap k a -> NonEmpty (NEMap k a)
isSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => NEMap k a -> NEMap k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> NEMap k a -> NEMap k b -> Bool
lookupIndex :: Ord k => k -> NEMap k a -> Maybe Int
findIndex :: Ord k => k -> NEMap k a -> Int
elemAt :: Int -> NEMap k a -> (k, a)

-- | Variant of <a>updateAt</a> that disallows deletion. Allows us to
--   guarantee that the result is also a non-empty Map.
adjustAt :: (k -> a -> a) -> Int -> NEMap k a -> NEMap k a
updateAt :: (k -> a -> Maybe a) -> Int -> NEMap k a -> Map k a
deleteAt :: Int -> NEMap k a -> Map k a
take :: Int -> NEMap k a -> Map k a
drop :: Int -> NEMap k a -> Map k a
splitAt :: Int -> NEMap k a -> (Map k a, Map k a)
findMin :: NEMap k a -> (k, a)
findMax :: NEMap k a -> (k, a)
deleteMin :: NEMap k a -> Map k a
deleteMax :: NEMap k a -> Map k a
deleteFindMin :: NEMap k a -> ((k, a), Map k a)
deleteFindMax :: NEMap k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> NEMap k a -> Map k a
updateMax :: (a -> Maybe a) -> NEMap k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> NEMap k a -> Map k a
minView :: NEMap k a -> (a, Map k a)
maxView :: NEMap k a -> (a, Map k a)

-- | <i>O(n)</i>. Test if the internal map structure is valid.
valid :: Ord k => NEMap k a -> Bool
